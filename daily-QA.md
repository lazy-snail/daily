# 0730
# 锁
## 为什么产生死锁？
死锁发生于多道程序设计环境中，若干进程需要共享一些资源，而一个进程所需要的资源可能有多种类型，如打印机、内存块等，因此就有可能出现多个进程对相同资源的竞争和等待，不合理的推进顺序会导致这种竞争和等待会无限循环地僵持下去，形成环路，这种状态就是进程死锁。
死锁产生的条件：
1. 互斥条件：一个资源每次只能被一个进程使用；
2. 占有并等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放；
3. 不可抢占：进程已获得的资源，在末使用完之前，不能强行剥夺；
4. 循环等待：若干进程之间形成一种头尾相接的循环等待资源关系。

## 如何检测死锁
死锁一旦出现，业务是可感知的，因为无法继续提供服务，这时候通过将线程信息dump出（通过jstack 或 vmvisual等工具），可以查看哪个线程出现了类似“Blocked”信息，即有可能该线程出现了死锁。

## 避免死锁的常用方法
* 避免一个线程同时获得多个锁；
* 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源；
* 尝试使用定时锁，使用 lock.tryLock(timeout)来代替使用内部锁机制；
* 对于数据库锁，加锁和解锁必须在同一个数据库连接里，否则会出现解锁失败的情况。
etc.

## 什么时候需要同步？
* 如果一个变量正在被修改，而接下来它有可能被另一个线程读取，或者正在读取一个上一次已经被某个线程修改过的变量，就必须使用同步；
* 每个需要访问临界数据的方法都需要同步机制。

# 0728
jdk new feature
spring framework
redis
kafka
ES
netty
zk
docker

# 0721
人人都是产品经理这句话挺害人的，以至于仍处于野蛮生长期的东家真的混进来了很多不怎么懂产品的PM，当然我是开发我也不太懂，但好歹把《人月神话》、HCI之类的东西看一看学一学，实在不行，亲自做个用户，也比“我觉得xxx”好很多。

# 0716
IO设备是计算机系统的瓶颈。

# 0604
懂管理、懂技术、懂业务

关注一些公众号的初衷是想利用一下碎片时间，然而愈加低质的内容和广告量的增加实在是劝退。比如这种文章：https://mp.weixin.qq.com/s/HA7YOn0qFNJFdrSNUJLp3A，我都怀疑是文科生写的（意思纯粹是表达这作者不专业）。
挨个来：第一个，switch在不同语言表现是相同的，java只是选了一种看上去不那么优雅的方式而已，这个可以勉强算，但说坑倒也不至于；
第二个就显得有点蠢了，包括现代cpu在内，分支优化一直是各种优化措施的重点，而且逻辑短路、fast-fail等设计难道不是优解吗，作者是不是该举一个非逻辑短路的例子？
第三个恰好之前看过一篇：http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html，选1开始没问题，但逻辑上可能更糟糕，毕竟计算机一路发展过来可是一直很在意0的。
第四个，这什么鬼，看不下去了，还交叉转载。。。

# 0427
HashMap加载因子为 .75，不是因为这样“符合泊松分布”，随机哈希的存放数据方式本身就是满足泊松分布的，加载因子只是会影响到分布的PMF（概率质量函数probability mass function）。关于为什么是 .75，类开头的注释是：作为一般规则，默认的负载因子在时间和空间成本上提供了很好的折衷。扩容为原来容量的2倍。

# 0426
private修饰的方法可以通过反射访问，那么private的意义是什么？
private是OOP的封装的概念，用于隐藏部分实现的细节，而只暴露接口，它并不是设计来解决安全问题的，代码的安全问题由别的方法解决。但setAccessible()显然会破坏类的访问规则，产生安全隐患。
一些观点：
1. public/protected/default/private，要做的是不暴露内部实现，但在一些特殊情况下，需要关注甚至修改内部实现（性能/测试环境/使用场景），这种例外的存在并不影响封装的理念，更多的是表达一种“知道这么多就够客户端使用者使用了”，而不是为了表达“这是机密，绝不能让外人看到”；

# 0425
为什么 wait，notify 和 notifyAll 是在 Object 类中定义的而不是在 Thread 类中定义

—————————————————————————————————————— reverse
# 0704
关于try-catch-finally中，finally的作用，finally设计之初就是为了关闭资源，如果在finally中使用return语句，会覆盖try或者catch的返回值，最常见的就是覆盖异常，即便catch往上抛了异常，也会被覆盖，返回finally中return语句的返回值。

# 0705
数据库中，凡是涉及到字符类型比较或排序的地方，都会和COLLATE有关。

# 0708

# 0724
使用equals()方法时，把一定不为null的放在前面；
打日志引用变量也可能打出NullPointer

# 1017
Why Numbering Should Start at Zero:
http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html

# 0120
字符串匹配算法，主要有：
RK算法：https://mp.weixin.qq.com/s/S3zyURB7WMSGN0nH70_HSw
KMP算法：http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html
BM算法：https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html

# 0323
拷贝：数组拷贝的四种方法：for循环、arr.clone()、System.arraycopy()、Arrays.copyof()，均为浅拷贝。

# 0324
ArrayList 扩容为1.5倍

# 0325
HashMap加载因子为 .75，不是因为这样“符合泊松分布”，随机哈希的存放数据方式本身就是满足泊松分布的，加载因子只是会影响到分布的PMF（概率质量函数probability mass function）。关于为什么是 .75，类开头的注释是：作为一般规则，默认的负载因子在时间和空间成本上提供了很好的折衷。扩容为原来容量的2倍。

# 0328
TreeMap
基于红黑树，key必须实现Comparator接口，且不可为null（废话，null不可用于比较，而实现了Comparator接口的对象也就不会是null，否则在这里就已经NPE了），