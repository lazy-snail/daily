---
title: MySQL-事务
date: 2018-04-09 14:31:19
tags: DB
---
**事务（Transaction）** 是数据库区别于文件系统的重要特性之一。事务会把数据库从一种一致状态转变为另一种一致状态：提交工作时，可以确保所有修改要么都被保存好了，要么都不保存。
以下内容以InnoDB为例。

#### 事务的__ACID__特性：
* 原子性（Atomicity）：指数据库的事务是不可分割的工作单位，即事务中任何一个SQL语句执行失败，已经成功的部分也必须撤销，数据库会退到执行事务之前的状态；
* 一致性（Consistency）：指事务将数据库从一种一致状态转变为下一种一致状态，在事务开始前和结束后，数据库的完整性约束没有被破坏，如列值的唯一性等；
* 隔离性（Isolation）：也称并发控制（Concurrency Control）、可串行化（Serializability）、锁（Locking）等。要求每个读写事务的对象对其它事务的操作对象之间能够相互分离，即该事务提交前对其它事务都不可见，通常使用锁来实现。当前数据库系统都提供了一种粒度锁（Granular Lock）的策略，允许事务仅锁住一个实体对象的子集，以此来提高事务的并发度；
* 持久性（Durability）：事务一旦提交，其结果就是永久性的，即使发生宕机等故障，数据库也能将数据恢复。持久性保证事务系统的高可靠性（High Reliability），但不能保证高可用性（High Availability）：_从事务本身的角度保证结果的永久性，但无法避免数据库本身的故障，如RAID卡损坏、自然灾害等_；

尽管理论上事务的定义需要满足这四个特性，但数据库厂商出于各种目的并不一定会完全遵循该准则。

#### 事务分类
从事务理论的角度来说，可以把事务分为以下几个类型：
* 扁平事务（Flat Transactions）：最简单的一种，也是实际生产环境中使用最为频繁的。所有操作都处于同一层次，由 BEGIN WORK 开始，由 COMMIT WORK / ROLLBACK WORK 结束，其间的操作都是原子的——要么都执行，要么都回滚。是应用程序成为原子操作的基本组成模块。三种执行结果如下：
{% asset_img flat-transaction.jpg 三种结果 %}
* 带有保存点的扁平事务（Flat Transactions with Savepoints）：允许事务执行过程中回滚到同一事务中较早的一个状态——某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点（Savepoint）用来通知系统应该记住事务当前的状态，以便之后发生错误时，事务能回滚到保存点的状态。（扁平事务隐式在起始点设置一个保存点，即只能回滚到事务开始的状态）。保存点用 SAVE WORK 函数来建立。在发生系统崩溃时会丢失所有保存点，因为保存点是易失的（Volatile），而非持久的（Persistent），这意味着进行恢复时，事务需要从开始处重新执行而不能从最近的一个保存点继续执行。
{% asset_img savepoint-transaction.jpg 在事务中使用保存点 %}
* 链事务（Chained Transactions）：可以看作保存点模式的一个变种。在提交事务时，释放不需要的数据对象（如事务所持有的锁），将必要的处理上下文隐式地传给下一个要开始的事务（提交事务操作和开始下一个事务操作将合并为一个原子操作）。这意味着，下一个事务将看到上一个事务的结果，就好像在一个事务中进行的一样：
{% asset_img chained-transaction.jpg 链事务工作方式 %}
链事务的回滚仅限于当前事务，即只能恢复到最近一个保存点。
* 嵌套事务（Nested Transactions）：层次结构框架，由一个顶层事务（top-level transaction）控制各个层次的事务，之下嵌套的事务称为子事务（subtransaction），其控制每一个局部的变换。
{% asset_img nested-transaction.jpg 嵌套事务的层次结构 %}
**定义：**
1. 由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务；
2. 处在叶节点的事务是扁平事务，但每个子事务从根到叶节点的距离可以不同；
3. 位于根节点的事务称为顶层事务，其他事务为子事务。事务的前驱（predecessor）称为父事务（parent），下一层称为子事务（child）；
4. 子事务既可以提交也可以回滚，但它的提交操作并不会马上生效，除非其父事务已经提交。因此，任何子事务都在顶层事务提交后才真正的提交；
5. 树中的任意一个事务的回滚都会引起它的所有子事务一同回滚，因此，子事务仅保留A、C、I特性，不具有D的特性。

在Moss的理论中，实际的工作是交由叶子节点完成的，即只有叶子节点的事务才能才能访问数据库、发送信息、获取其他类型的资源。而高层的事务仅负责逻辑控制，决定何时调用相关的子事务。即使一个系统不支持嵌套事务，用户也可以通过保存点技术来模拟嵌套事务，如图：
{% asset_img 模拟.jpg 保存点技术模拟嵌套事务 %}
* 分布式事务（Distributed Transactions）：通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。
假如一个用户在ATM机上进行银行的转账操作，例如持卡人从招商银行存储卡转账10000元到工商银行的存储卡。这种情况下，可以将ATM机视为节点A，招商银行的后台数据库视为节点B，工商银行的后台数据库视为C，这个转账的操作可分解为以下的步骤：
> 1. 节点A发出转账命令
> 2. 节点B执行存储卡中的余额减去10000
> 3. 节点C执行存储卡终端的余额增加10000
> 4. 节点A通知用户操作完成或者节点A通知用户操作失败

这里需要使用到分布式事务，因为节点A不能通过一台数据库就完成任务，其需要访问网络中两个节点的数据库，而在每个节点的数据库执行的实务操作又都是扁平的，对于分布式事务，其同样需要满足ACID特性，要么都发生，要么都失效。对于上述例子，如果2、3步中任何一个操作失败，都会导致整个分布式事务回滚，若非这样，结果非常可怕。

InnoDB存储引擎支持扁平事务、带有保存点的事务、链事务、分布式事务。MySQL数据库、InnoDB存储引擎都不原生支持嵌套事务，可通过带有保存点的扁平事务来模拟串行的嵌套事务。

#### 事务的实现
事务的A、C、D特性通过数据库的 redo log 和 undo log 完成。redo log 称为重做日志，用来保证事务的原子性、持久性，undo log 用来保证事务的一致性。事务的隔离性由锁来实现。
_undo 不是 redo 的逆过程。_ redo 和 undo 都可以看作是一种恢复操作，redo 恢复提交事务修改的页操作，undo 回滚行记录到某个特定版本：两者记录的内容不同，并且 redo 通常是物理日志，记录的是页的物理修改操作，undo 是逻辑日志，根据每行记录进行记录。

##### redo
重做日志记录了事务的行为，由两部分组成：内存中的重做日志缓冲（redo log buffer），易失的；重做日志文件（redo log file），持久的物理保存。都是以512字节的块进行存储：重做日志块（redo log block）。
通过 Force Log at Commit 机制实现事务的持久性，即当事务提交（commit）时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的commit操作完成才算完成。这里的日志分为两部分：redo log 和 undo log。redo log 基本是顺序写的，在数据库运行时不需要对 redo log 的文件进行读取操作，undo log 是需要进行随机读写的。
为确保日志写入重做日志文件，重做日志缓冲写入文件系统缓存后，会进行一次fsync操作，以将缓冲写入磁盘文件，该同步操作的参数 innodb_flush_log_at_trx_commit 可以手动设置：
* 1（默认）：事务提交时必须调用一次fsync操作；
* 0：事务提交时不调用fsync，而是放到 master thread 中完成（默认每秒调用一次）；
* 2：仅写入文件系统缓存，不进行fsync操作。宕机情况下会丢失未刷新到磁盘日志文件的那部分事务。

##### undo
对事务进行回滚操作。与redo存放在重做日志文件中不同，undo存放在数据库内部的一个特殊段（segment）中，这个段称为undo段（undo segment），位于共享表空间内。undo 是逻辑日志，只是将数据库逻辑地恢复到原来的样子，所有的修改都被逻辑地取消了：对于每个 INSERT，回滚执行一个 DELETE，相应的 DELETE、UPDATE也是同样执行一个相反的操作，将修改前的行放回去。
除了回滚操作，另一个作用是完成 MVCC：当拥护读取一行记录时，若该记录已经被其它事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读。
_**uodo log 会产生 redo log，也就是 uodo log 的产生会伴随这 redo log 的产生，因为 undo log 也需要持久性的保护。**_

**uodo log 格式**
InnoDB中，undo log 分为：
insert undo log：在INSERT操作中产生的undo log。因为INSERT操作记录只对本事务可见（隔离性的要求），对其它事务不可见，所以可以在事务提交后直接删除；
update undo log：在DELETE、UPDATE操作中产生的undo log，该undo log可能需要提供MVCC机制，因此不能在事务提交时就删除，提交时放入undo log链表，等待purge线程进行最后的删除。

##### purge
用于最终完成DELETE、UPDATE操作。DELETE、UPDATE操作可能不直接删除原有数据，可以仅将该行主键的delete flag设置为1，行记录本身暂时不执行删除操作，而是延时到最终的purge操作中完成。这样设计是因为InnoDB支持MVCC，所以记录不能在事务提交时立即进行处理。这时其它事务可能正在引用这行，故需要保存记录之前的版本。若该行记录已经不被任何其它事务引用，即可进行真正的删除操作。

##### group commit
为提高磁盘fsync操作的效率，数据库提供 group commit 功能使得一次fsync操作可以刷新多个事务日志到磁盘文件。

#### 事务的隔离级别
SQL标准定义了四个隔离级别：
READ UNCOMMITTED：称为浏览访问（browse access），
READ COMMITTED：（仅针对事务而言）称为游标稳定（cursor stability），
REPEATABLE READ：2.9999°的隔离，没有幻读的保护，
SERIALIZABLE：称为隔离/3°的隔离

InnoDB默认的隔离级别是 REPEATABLE READ，与标准SQL不同的是，该级别下，InnoDB使用 Next-Key Lock 锁算法避免幻读的产生。所以在该级别下已经完全能够保证事务的隔离性要求，即达到SQL标准的SERIALIZABLE隔离级别。
隔离级别越低，事务请求的锁越少或保持锁的时间越短。SERIALIZABLE隔离级别几乎不会带来性能问题，同样地，即使使用 READ COMMITTED 的隔离级别，也不会得到性能的大幅度提升。

#### 分布式事务

指的是允许多个独立的事务资源（Transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，也可以是其它类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚。使用分布式事务时，InnoDB的事务隔离级别必须设置为 SERIALIZABLE。

分布式事务在银行系统的转账中比较常见。
使用两段式提交（two-phase commit）的方式：
1. 所有参与全局事务的节点开始准备（PREPARE），告诉事务管理器它们已经准备好提交；
2. 事务管理器告诉资源管理执行COMMIT或者ROLLBACK。

如果任何一个节点显示不能提交，则所有的节点都被告知需要回滚。可见与本地事务不同的是，分布式事务需要多一次的PREPARE操作，待收到所有节点的同意信息后，再进行COMMIT或ROLLBACK操作。

**XA事务：**
XA是X/Open DTP组织（X/Open DTP group）定义的两阶段提交协议。在这个模型中，包括：
应用程序（Application Program）：定义事务的边界，指定全局事务中的操作；
事务管理器（Transaction Manager）：协调参与全局事务中的各个事务，需要和参与全局事务的所有资源管理器进行通信；
资源管理器（Resource Managers）：提供访问事务资源的方法，通常一个数据库就是一个资源管理器。
通信资源管理器（CRM）。
XA被许多数据库（Oracle、MySQL、SQL Server、DB2等）本地支持。
