---
title: 事务
date: 2018-04-09 14:31:19
categories: DB
tags: [DB, MySQL]
---
**事务（Transaction）** 是数据库区别于文件系统的重要特性之一。事务会把数据库从一种一致状态转变为另一种一致状态：提交工作时，可以确保所有修改要么都被保存好了，要么都不保存。

# ACID 特性
* 原子性（Atomicity）：指数据库的事务是不可分割的工作单位，即事务中任何一个SQL语句执行失败，已经成功的部分也必须撤销，数据库会退到执行事务之前的状态；
* 一致性（Consistency）：指事务将数据库从一种一致状态转变为下一种一致状态，在事务开始前和结束后，数据库的完整性约束没有被破坏，如列值的唯一性等；
* 隔离性（Isolation）：也称并发控制（Concurrency Control）、可串行化（Serializability）、锁（Locking）等。要求每个读写事务的对象对其它事务的操作对象之间能够相互分离，即该事务提交前对其它事务都不可见，通常使用锁来实现。当前数据库系统都提供了一种粒度锁（Granular Lock）的策略，允许事务仅锁住一个实体对象的子集，以此来提高事务的并发度；
* 持久性（Durability）：事务一旦提交，其结果就是永久性的，即使发生宕机等故障，数据库也能将数据恢复。持久性保证事务系统的高可靠性（High Reliability），但不能保证高可用性（High Availability）：_从事务本身的角度保证结果的永久性，但无法避免数据库本身的故障，如RAID卡损坏、自然灾害等_；

_尽管理论上事务的定义需要满足这四个特性，但数据库厂商出于各种目的并不一定会完全遵循该准则_。

# 事务分类
从事务理论的角度来说，可以把事务分为以下几个类型：

## 扁平事务（Flat Transactions）
最简单的一种，也是实际生产环境中使用最为频繁的。所有操作都处于同一层次，由 BEGIN WORK 开始，由 COMMIT WORK / ROLLBACK WORK 结束，其间的操作都是原子的——要么都执行，要么都回滚。是应用程序成为原子操作的基本组成模块。三种执行结果如下：
{% asset_img flat-transaction.jpg 三种结果 %}

## 带有保存点的扁平事务（Flat Transactions with Savepoints）
允许事务执行过程中回滚到同一事务中较早的一个状态——某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点（Savepoint）用来通知系统应该记住事务当前的状态，以便之后发生错误时，事务能回滚到保存点的状态。（扁平事务隐式在起始点设置一个保存点，即只能回滚到事务开始的状态）。保存点用 SAVE WORK 函数来建立。在发生系统崩溃时会丢失所有保存点，因为保存点是易失的（Volatile），而非持久的（Persistent），这意味着进行恢复时，事务需要从开始处重新执行而不能从最近的一个保存点继续执行。
{% asset_img savepoint-transaction.jpg 在事务中使用保存点 %}

## 链事务（Chained Transactions）
可以看作保存点模式的一个变种。在提交事务时，释放不需要的数据对象（如事务所持有的锁），将必要的处理上下文隐式地传给下一个要开始的事务（提交事务操作和开始下一个事务操作将合并为一个原子操作）。这意味着，下一个事务将看到上一个事务的结果，就好像在一个事务中进行的一样：
{% asset_img chained-transaction.jpg 链事务工作方式 %}
链事务的回滚仅限于当前事务，即只能恢复到最近一个保存点。

## 嵌套事务（Nested Transactions）
层次结构框架，由一个顶层事务（top-level transaction）控制各个层次的事务，之下嵌套的事务称为子事务（subtransaction），其控制每一个局部的变换。
{% asset_img nested-transaction.jpg 嵌套事务的层次结构 %}
**嵌套事务的定义**
* 由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务；
* 处在叶节点的事务是扁平事务，但每个子事务从根到叶节点的距离可以不同；
* 位于根节点的事务称为顶层事务，其他事务为子事务。事务的前驱（predecessor）称为父事务（parent），下一层称为子事务（child）；
* 子事务既可以提交也可以回滚，但它的提交操作并不会马上生效，除非其父事务已经提交。因此，任何子事务都在顶层事务提交后才真正的提交；
* 树中的任意一个事务的回滚都会引起它的所有子事务一同回滚，因此，子事务仅保留 A、C、I 特性，不具有 D 的特性。

在Moss的理论中，实际的工作是交由叶子节点完成的，即只有叶子节点的事务才能才能访问数据库、发送信息、获取其他类型的资源。而高层的事务仅负责逻辑控制，决定何时调用相关的子事务。即使一个系统不支持嵌套事务，用户也可以通过保存点技术来模拟嵌套事务：
{% asset_img 模拟.jpg 保存点技术模拟嵌套事务 %}

## 分布式事务（Distributed Transactions）
通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）。
假如一个用户在 ATM 机上进行银行的转账操作，例如持卡人从招商银行存储卡转账 10000 元到工商银行的存储卡。这种情况下，可以将 ATM 机视为节点 A，招商银行的后台数据库视为节点 B，工商银行的后台数据库视为 C，这个转账的操作可分解为以下的步骤：
> 1. 节点 A 发出转账命令
> 2. 节点 B 执行存储卡中的余额减去 10000
> 3. 节点 C 执行存储卡终端的余额增加 10000
> 4. 节点 A 通知用户操作完成或者节点 A 通知用户操作失败

这里需要使用到分布式事务，因为节点 A 不能通过一台数据库就完成任务，其需要访问网络中两个节点的数据库，而在每个节点的数据库执行的实务操作又都是扁平的，对于分布式事务，其同样需要满足 ACID 特性，要么都发生，要么都失效。对于上述例子，如果 2、3 步中任何一个操作失败，都会导致整个分布式事务回滚，若非这样，结果不可预知。


**InnoDB 支持的事务类型**
InnoDB存储引擎支持扁平事务、带有保存点的事务、链事务、分布式事务。MySQL数据库、InnoDB存储引擎都不原生支持嵌套事务，可通过带有保存点的扁平事务来模拟串行的嵌套事务。

# 事务的实现
事务的 A、C、D 特性通过数据库的 redo log 和 undo log 完成。redo log 称为重做日志，用来保证事务的原子性、持久性，undo log 用来保证事务的一致性。事务的隔离性由锁来实现。
_undo 不是 redo 的逆过程。_ redo 和 undo 都可以看作是一种恢复操作，redo 恢复提交事务修改的页操作，undo 回滚行记录到某个特定版本：两者记录的内容不同，并且 redo 通常是物理日志，记录的是页的物理修改操作，undo 是逻辑日志，根据每行记录进行记录。

## redo
重做日志记录了事务的行为，由两部分组成：内存中的重做日志缓冲（redo log buffer），易失的；重做日志文件（redo log file），持久的物理保存。都是以512字节的块进行存储：重做日志块（redo log block）。
通过 Force Log at Commit 机制实现事务的持久性，即当事务提交（commit）时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的commit操作完成才算完成。这里的日志分为两部分：redo log 和 undo log。redo log 基本是顺序写的，在数据库运行时不需要对 redo log 的文件进行读取操作，undo log 是需要进行随机读写的。
为确保日志写入重做日志文件，重做日志缓冲写入文件系统缓存后，会进行一次fsync操作，以将缓冲写入磁盘文件，该同步操作的参数 innodb_flush_log_at_trx_commit 可以手动设置：
* 1（默认）：事务提交时必须调用一次fsync操作；
* 0：事务提交时不调用fsync，而是放到 master thread 中完成（默认每秒调用一次）；
* 2：仅写入文件系统缓存，不进行fsync操作。宕机情况下会丢失未刷新到磁盘日志文件的那部分事务。

## undo
对事务进行回滚操作。与redo存放在重做日志文件中不同，undo存放在数据库内部的一个特殊段（segment）中，这个段称为undo段（undo segment），位于共享表空间内。undo 是逻辑日志，只是将数据库逻辑地恢复到原来的样子，所有的修改都被逻辑地取消了：对于每个 INSERT，回滚执行一个 DELETE，相应的 DELETE、UPDATE也是同样执行一个相反的操作，将修改前的行放回去。
除了回滚操作，另一个作用是完成 MVCC：当拥护读取一行记录时，若该记录已经被其它事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读。
_uodo log 会产生 redo log，也就是 uodo log 的产生会伴随这 redo log 的产生，因为 undo log 也需要持久性的保护_。

**uodo log 格式**
InnoDB 中，undo log 分为：
insert undo log：在 INSERT 操作中产生的 undo log。因为 INSERT 操作记录只对本事务可见（隔离性的要求），对其它事务不可见，所以可以在事务提交后直接删除；
update undo log：在 DELETE、UPDATE 操作中产生的 undo log，该 undo log 需要提供 MVCC 机制，因此不能在事务提交时就删除，提交时放入 undo log 链表，等待 purge 线程进行最后的删除。

## purge
用于最终完成 DELETE、UPDATE 操作。DELETE、UPDATE 操作可能不直接删除原有数据，可以仅将该行主键的 delete flag 设置为 1，行记录本身暂时不执行删除操作，而是延时到最终的 purge 操作中完成。这样设计是因为 InnoDB 支持 MVCC，所以记录不能在事务提交时立即进行处理。这时其它事务可能正在引用这行，故需要保存记录之前的版本。若该行记录已经不被任何其它事务引用，即可进行真正的删除操作。

## group commit
为提高磁盘 fsync 操作的效率，数据库提供 group commit 功能使得一次 fsync 操作可以刷新多个事务日志到磁盘文件。


# 概念
## XA 规范
XA 是 X/Open DTP 组织（X/Open DTP group）定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供（MySQL、Oracle、SQL Server、DB2等数据库都本地支持）。在这个模型中，包括：
* 应用程序（Application Program）：定义事务的边界，指定全局事务中的操作；
* 事务管理器（Transaction Manager）：协调参与全局事务中的各个事务，需要和参与全局事务的所有资源管理器进行通信；
* 资源管理器（Resource Managers）：提供访问事务资源的方法，通常一个数据库就是一个资源管理器。
* 通信资源管理器（CRM）。

两阶提交协议和三阶提交协议就是根据这一思想衍生出来的。可以说两阶段提交其实就是实现 XA 分布式事务的关键(两阶段提交主要保证了分布式事务的原子性)。

## 两阶段提交协议
two phase commit protocol，2PC。在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的 ACID 特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，两阶段提交的算法思路可以概括为：**参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作**。

所谓的两个阶段是指：第一阶段：准备阶段(投票阶段)和第二阶段：提交阶段（执行阶段）。
### 准备阶段
事务管理器（事务协调者）给每个资源管理器（事务参与者）发送 Prepare 消息，每个参与者要么直接返回失败（如权限验证失败），要么在本地执行事务，并且写本地的 redo 和 undo 日志，但不提交，而是处于一种“准备好了”的状态：
1. 协调者向所有参与者询问是否可以执行提交操作（vote），并开始等待它们的响应；
2. 参与者执行询问发起为止的所有事务操作，并将 undo 和 redo 信息写入日志；
3. 各参与者响应协调者发起的询问，如果参与者成功执行事务操作，返回“同意”，否则返回“终止”。

### 提交阶段
如果协调者收到了（任一）参与者的失败消息或者超时，那么直接给每个参与者发送回滚（Rollback）消息；否则，发送提交（Commit）消息。参与者根据收到的指令执行回滚/提交操作，随之释放所有事务处理过程中使用的锁资源(必须在最后阶段释放锁资源)。不管最后结果如何，第二阶段都会结束当前事务。

#### 提交
{% asset_img 2pc-commit.png 提交 %}
如果进入提交阶段（所有参与者都返回的是“同意”消息）：
1. 协调者节点向所有参与者节点发出“正式提交(commit)”的请求。
2. 参与者节点正式完成操作，并释放在整个事务期间内占用的资源。
3. 参与者节点向协调者节点发送”完成”消息。
4. 协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。

#### 回滚
{% asset_img 2pc-fail.png 回滚 %}
如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：
1. 协调者节点向所有参与者节点发出“回滚操作(rollback)”的请求。
2. 参与者节点利用之前写入的 undo 信息执行回滚，并释放在整个事务期间内占用的资源。
3. 参与者节点向协调者节点发送“回滚完成”消息。
4. 协调者节点受到所有参与者节点反馈的“回滚完成”消息后，取消事务。

### 存在的问题
* 同步阻塞问题
执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
* 单点故障
由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）。
* 数据不一致
在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送 commit 请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了 commit 请求。而在这部分参与者接到commit请求之后就会执行 commit 操作。但是其他部分未接到 commit 请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。
* 无法解决的问题：协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。

## 三阶段提交协议
three phase commit protocol，3PC。2PC 的改进版。3PC 主要解决的单点故障问题，并减少阻塞。

[参考]
http://www.hollischuang.com/archives/681