---
title: MySQL-存储引擎
date: 2018-04-06 00:17:30
tags: DB
---
MySQL 体系结构如图所示：
{% asset_img arch.png 体系结构 %}
由上图可以看出，MySQL由以下几部分组成：
* 连接池组件；
* 管理服务和工具组件；
* SQL 接口组件；
* 查询分析器组件；
* 优化器组件；
* 缓冲（Cache）组件；
* 插件式存储引擎；
* 物理文件；

其中，MySQL 数据库区别于其他数据库的最重要的一个特点就是其**插件式**的表存储引擎。并且为这种架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，作为底层物理结构的实现，每个存储引擎按照自己的意愿进行开发。MySQL 的核心就在于存储引擎。
**存储引擎是基于表的，而不是数据库。**

下面是MySQL几种存储引擎特性对比：
{% asset_img 对比.png 对比 %}
可以看出，不同存储引擎对诸如事务、全文索引等的支持是不同的；另外对B-树等索引、锁机制等的具体算法实现也有很大差异。

#### 常用存储引擎对比
选取 MySQL 中较为常用的 InnoDB、MyISAM、MEMORY、Archive 四个存储引擎作为对比。它们都有各自适用的环境，这取决于其独有的一些特征。主要体现在性能、事务、并发控制、参照完整性、缓存、 故障恢复，备份及回存等几个方面。
##### InnoDB
* MySQL 5.7.x 默认的存储引擎为 InnoDB，被设计成适用于高并发读写的情况。使用MVCC(Multi-Version Concurrency Control)以及行级锁来提供遵从ACID的事务支持，提供了具有__提交、回滚和崩溃恢复能力的事务安全__，对比MyISAM的存储引擎，InnoDB 写处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。
* 提供**外键约束**（MySQL 中只有 InnoDB 支持外键约束）。在创建外键的时候，父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。在创建索引的时候，可以指定在删除、更新父表时，对子表进行的相应操作，包括restrict、cascade、set null和no action。其中restrict和no action相同，是指限制在子表有关联的情况下，父表不能更新；casecade表示父表在更新或删除时，更新或者删除子表对应的记录；set null 则表示父表在更新或者删除的时候，子表对应的字段被set null。
* 在行级别上对表数据上锁，提供非锁定读。行级锁没有相关额外的开销，并可以同时得到并发性和一致性。
* 使用 Next-Key Lock 算法来避免不可重复读问题。MySQL 文档中将不可重复读问题定义为（Phantom Problem），即幻读问题。

适合场景：
* 可靠性要求较高
* 要求事务
* 表更新和查询都相当频繁，锁定表的可能性较大，等

##### MyISAM
不支持事务，也不支持外键。访问速度快，占用内存较少。数据文件和索引文件可以分开存储，平均分配IO以获取更快的速度。每个MyISAM表在磁盘上存储3个文件：
* .frm（存储表定义）
* MYD（MYData，存储数据）
* MYI（MYIndex，存储索引）

MyISAM表支持3种不同的存储格式：
* 静态(固定长度)表
* 动态表
* 压缩表

其中静态表是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多。静态表在数据存储时会根据列定义的宽度定义补足空格，但是在访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。同时需要注意：在某些情况下可能需要返回字段后的空格，而使用这种格式时后面到空格会被自动处理掉。
动态表包含变长字段，记录不是固定长度的，这样存储的优点是占用空间较少，但是频繁到更新删除记录会产生碎片，需要定期执行OPTIMIZE TABLE语句或myisamchk -r命令来改善性能，并且出现故障的时候恢复相对比较困难。
压缩表由myisamchk工具创建，占据非常小的空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支。

适合场景：
* 对事务完整性没有要求；
* 插入不频繁、查询非常频繁；等

**MERGE**
MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，MERGE表中并没有数据，对MERGE类型的表可以进行查询、更新、删除的操作，这些操作实际上是对内部的MyISAM表进行操作。对于对MERGE表进行的插入操作，是根据INSERT_METHOD子句定义的插入的表，可以有3个不同的值，first和last值使得插入操作被相应的作用在第一个或最后一个表上，不定义这个子句或者为NO，表示不能对这个MERGE表进行插入操作。可以对MERGE表进行drop操作，这个操作只是删除MERGE表的定义，对内部的表没有任何影响。MERGE在磁盘上保留2个以MERGE表名开头文件：.frm文件存储表的定义；.MRG文件包含组合表的信息，包括MERGE表由哪些表组成，插入数据时的依据。可以通过修改.MRG文件来修改MERGE表，但是修改后要通过flush table刷新。

##### MEMORY
MEMORY使用存在内存中的内容来创建表。每个MEMORY表实际对应一个磁盘文件，格式是.frm。MEMORY类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用HASH索引，但是一旦服务器关闭，表中的数据就会丢失，但表还会继续存在。
默认情况下，MEMORY数据表使用散列索引，利用这种索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了。因此，散列索引值适合使用在"="和"<=>"的操作符中，不适合使用在"<"或">"操作符中，也同样不适合用在order by字句里。如果确实要使用"<"或">"或betwen操作符，可以使用B-tree索引来加快速度。
存储在MEMORY数据表里的数据行使用的是长度不变的格式，因此加快处理速度，这意味着不能使用BLOB和TEXT这样长度可变的数据类型。VARCHAR是一种可变长类型，但因为它在MySQL内部被当作长度固定不变的CHAR类型，所以可以使用。
