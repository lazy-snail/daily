---
title: MySQL-锁
date: 2018-04-09 17:03:14
tags: [DB, 并发]
---
多用户、数据库驱动的应用中，很大的一个难点是：一方面要最大程度地利用数据库的并发访问，一方面要确保每个用户能以一致的方式读取和修改数据。为此有了锁（locking）机制。
锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并发访问，提供数据的完整性和一致性。
InnoDB提供一致性的非锁定读、行级锁支持。行级锁没有相关额外的开销，并可以同时得到并发性和一致性。

_**latch 和 lock**_
两者都可以称为“锁”。latch一般称为闩锁（轻量级的锁），对象是线程，因为其要求锁定的时间必须非常短，若持续时间长，则应用的性能会非常差，在InnoDB中，latch又分为mutex（互斥量）和rwlock（读写锁），目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制；lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行等，一般lock的对象仅在事务commit/rollback后进行释放（不同事务隔离级别释放的时间可能不同），有死锁检测机制。

#### InnoDB中的锁类型
* __共享锁（S Lock）__：允许事务读一行数据；
* __排他锁（X Lock）__：允许事务删除或更新一行数据；

如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁，因为读取并不会改变行r的数据，这种情况为 **锁兼容（Lock Compatible）**。S和X都是行锁，兼容是指对同一行记录（row）锁的兼容性情况。
InnoDB支持多粒度（granular）锁定，允许事务在行级上的锁和表级上的锁同时存在。为此，InnoDB支持一种额外的表级别锁方式——意向锁（Intention Lock）：将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度（fine granularity）上进行加锁。设计目的是为了在一个事务中揭示下一行将被请求的锁类型。支持两种意向锁：
* __意向共享锁（IS Lock）__：事务想要获得一张表中某几行的共享锁；
* __意向排他锁（IX Lock）__：事务想要获得一张表中某几行的排他锁。

由于InnoDB支持的是行级别的锁，因此意向锁不会阻塞除全表扫描以外的任何请求。锁的兼容性如下：
{% asset_img InnoDB锁兼容性.PNG InnoDB 锁的兼容性 %}

##### 一致性非锁定读（Consistent Nonlocking Read）
指InnoDB通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上的锁释放。而是，InnoDB会去读取该行的一个快照数据：
{% asset_img 一致性非锁定读.PNG 一致性非锁定读 %}
之所以称之为非锁定读，因为不需要等待访问的行上X锁的释放。
快照数据是指该行的之前版本的数据，一个行记录可能有不止一个快照数据（即所谓的多版本技术），该实现是通过undo段来完成，而undo用来在事务中回滚数据，因此快照数据本身没有额外开销。此外，读取快照数据不需要上锁，因为没有事务需要对历史数据进行修改操作。
非锁定读机制极大提高了数据库的并发性，在InnoDB默认设置下，这是默认的读取方式。不用事务隔离级别下，读取的方式不同：
* __READ COMMITTED__：总是读取行的最新版本，锁定则读最新快照版本；
* __REPEATABLE__：总是读取事务开始时的行数据。

##### 一致性锁定读
某些情况下，用户需要显式地对数据库读取操作加锁，以保证数据逻辑的一致性。InnoDB对于SELECT语句支持两种一致性的锁定读（Locking Read）操作：
* __SELECT...FOR UPDATE__：对读取的行记录加一个X锁，
* __SELECT...LOCK IN SHARE MODE__：对读取的行记录加一个S锁。

上述语句必须在一个事务中，当事务提交了，锁也就释放了。因此要加上  BEGIN，START TRANSACTION 或 SET AUTOCOMMIT=0。

##### 外键和锁
InnoDB中，如果外键列没有显式添加索引，则自动对其添加一个索引——以避免表锁。

#### 锁的算法
InnoDB由3中行锁算法：
* __Record Lock__：单个行记录上的锁，总是锁住索引记录，如果表上没有索引，则使用隐式的主键进行锁定；
* __Gap Lock__：间隙锁，锁定一个范围，但不包含记录本身；
* __Next-Key Lock__：Record Lock + Gap Lock，锁定一个范围，并锁定记录本身。为了解决幻读问题（Phantom Problem）。当查询的索引含有唯一属性时，InnoDB会将其优化降级为Record Lock，即仅锁住索引本身而不再是范围。

_**幻读问题（Phantom Problem）**_
MySQL官方文档将不可重复读问题定义为幻读问题，指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。
默认事务隔离级别（REPEATABLE READ）下，采用上述Next-Key Lock机制避免幻读问题：锁定事务中SQL语句查询的范围，任何其它事务在次范围的数据修改都不允许，直到事务提交。
_事务隔离级别为 READ COMMITTED 时，仅采用 Record Lock。_

#### 锁导致的问题
因为事务隔离性的要求，锁只会带来三种问题：
* __脏读（Dirty Read）__：指在不同的事务下，当前事务可以读到其它事务尚未提交的数据，即读到脏数据,，这违反了事务的**隔离性**的要求。实际生产环境中，脏读并不常发生，因为要在事务的隔离级别为 READ UNCOMMITTED 时才有可能，而目前绝大部分数据库都至少在 READ COMMITTED 级别；
* __不可重复读__：即幻读，指在一个事务内多次读取同一数据集合，在该事务还没有结束时，其它事务也访问该数据集合，并做了一些DML操作，从而导致第一个事务的两次读数据之间可能产生不一致的结果。InnoDB采用 Next-Key Lock 解决该问题。
_不可重复读和脏读的区别是：脏读是读到未提交的数据，而不可重复读读到的是已经提交的数据，但是其违反了数据库事务**一致性**的要求_
* __丢失更新__：一个事务更新操作会被其它事务的更新操作覆盖，从而导致数据的不一致。例如：
　　1. 事务T1将行记录r更新为v1，但是事务T1未提交；
　　2. 此时，事务T2将行记录r更新为v2，事务T2未提交；
　　3. 事务T1提交；
　　4. 事务T2提交。
但是，当前数据库的任何隔离级别下都不会导致数据库理论意义上的丢失更新问题。因为即使在 READ UNCOMMITTED，对于行的DML操作，也需要对行或其它粗粒度级别的对象加锁，因此上述步骤2中，事务T2并不能对行记录r进行更新操作而会被阻塞，直到事务T1提交。

_**脏页 & 脏数据**_
* __脏页__ 指在缓冲池中已经被修改但还没有刷新到磁盘中的页，即数据库实例内存中的页和磁盘中的页数据不一致。读取脏页是正常的，因为脏页是由于数据库实例内存和磁盘的异步造成的，并且修改都已经被写入重做日志中，并不会影响数据的一致性，而异步刷新不影响数据库的可用性，并且带来性能的提高；
* __脏数据__ 则不同，是指事务对缓冲池中行记录的修改，并且还没有被提交（commit）。如果读到脏数据，即一个事务可以读到其它事务中未提交的数据，显然违反了事务的隔离性要求。

#### 阻塞
指由于不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源。阻塞并不是一件坏事，是为了确保事务可以并发且正常执行。超时会跑出1205错误。调整参数↓
innodb_lock_wait_timeout：设置等待时间（默认50秒），可动态调整；
innodb_rollback_on_timeout：设置是否在等待超时时对进行中的事务进行回滚操作（默认OFF，不回滚），静态的，不可在启动时修改。

#### 死锁
指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种相互等待的现象。
解决死锁最简单的方式是不要有等待，将任何的等待都转化为回滚，并且重新开始事务。然而这将导致并发性能的下降甚至所有的事务都无法进行。
另一种解决方法是超时，即当事务相互等待时，当其中一个事务等待时间超过设置的阈值，进行回滚操作，这时其它事务就有可能继续执行。InnoDB中超时设置参数：innodb_lock_wait_timeout（默认50秒）。
超时机制虽然简单，但若超时的事务所占权重较大，如操作更新了很多行，占用了较多的undo log，此时回滚该事务的时间相比于其它事务所占用的时间可能更多。因此除了超时机制外，当前数据库普遍采用 wait_for graph（等待图）的方式来进行死锁检测。较之超时的解决方案，这是一种更为主动的死锁检测方式。等待图要求数据库保存以下两种信息：
* 锁的信息链表；
* 事务等待链表；

通过上述链表构造出一张图，如果这个图中存在回路，就代表存在死锁，此时InnoDB选择回滚undo量最小的事务。
等待图的死锁检测通常采用深度优先的非递归算法实现（1.2.x版本之后，之前采用递归的深度优先算法实现）。

**乐观锁 vs 悲观锁（互斥同步 非互斥同步）**
并发控制技术手段上的概念。
乐观锁（Optimistic Lock）：假设数据一般情况下不会发生并发冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。如果冲突，则返回错误，让用户决定如何去做，这意味着乐观锁不能解决脏读问题。实现：
* 使用数据版本记录机制实现。为数据增加一个版本标识，如“version”，每更新一次数据，则对标识进行一次累加操作。
* 时间戳（timestamp）记录机制：在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果不一致则冲突。

适用于多读少写的场景，可以提高吞吐率。

悲观锁（Pessimistic Lock）：假定数据会发生并发冲突，从而以预防冲突的方式屏蔽一切可能违反数据完整性的冲突操作。简言之就是每次读写数据都认为会被其他线程修改，所以都需要上锁。java synchronized 就属于悲观锁的一种实现。
