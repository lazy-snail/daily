---
title: cpp-容器-vector
date: 2018-05-29 15:12:39
categories: C++
tags: [C++, 容器]
---
## vector
vector是STL序列式容器的一种，动态可变大小数组，基于数组实现，**支持快速随机访问，但在尾部之外的位置插入/删除元素可能很慢**（C++ primer）。与array十分相似，差别在于空间运用的灵活性，vector使用动态空间，随着元素的加入，内部可以自行扩充空间以容纳新元素。实现中的技术在于 **对大小的控制和重新配置时的数据移动效率**。

## 容量变化
在C++ 标准中，并没有规定 vector::push_back() 要用哪一个增长因子。这是由标准库的实现者决定的。经测试发现，VS 环境下是1.5倍增长，而 Linux 下使用编译运行发现，是2倍率增长。
可以用 reserve() 函数指定初始容量。
增长包括重新分配内存空间、拷贝原空间、释放原空间三个过程，具体策略为当添加元素时，如果 vector 空间大小不足，则会以原大小的1.5倍另外配置一块较大的新空间，然后将原空间内容拷贝过来，在新空间的内容末尾添加元素，并释放原空间。也就是说 vector 的空间动态增加大小，并不是在原空间之后的相邻地址增加新空间，因为 vector 的空间是线性连续分配的，不能保证原空间之后有可供配置的空间。
* 空的 vector 对象，size() 和 capacity() 都为0;
* 当空间大小不足时，新分配的空间大小为原空间大小的2倍;
* 使用 reserve() 预先分配一块内存后，在空间未满的情况下，不会引起重新分配，从而提升了效率;
* 当 reserve() 分配的空间比原空间小时，是不会引起重新分配的;
* resize() 函数只改变容器的元素数目，未改变容器大小。

### 为什么是成倍增长，而不是每次增长一个固定大小的容量？
如果以成倍方式增长，假定有n个元素，倍增因子为m：完成n个元素的push_back操作需要重新分配内存的次数约为 logm(n)，第i次重新分配会导致 m^(i) 次复制，也就是当前的 vector.size() 大小，n 次 push_back 操作所花费的时间复杂度为 O(n)，如下：
{% asset_img n-push_back.png 倍增n次push_back耗时 %}
可知，每次 push_back 耗时均摊为 O(1) 的时间复杂度。
相应地，如果以固定大小方式增长，假定有n个元素，每次增加k个，第i次增加复制的数量为为 ki；n 次 push_back  操作所花费的时间复杂度为 O(n^2)，均摊下来每次 push_back 操作的时间复杂度为 O(n)：
{% asset_img n-push_back1.png 固定大小n次push_back耗时 %}

对比可见采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到 O(n) 的时间复杂度，因此，使用成倍的方式扩容。

### 为什么是以2倍或者1.5倍增长，其他行不行？
《算法导论》中关于摊还分析显示，这是一种 **空间和时间的权衡**：空间分配的多，平摊时间复杂度低，但浪费空间也多。
使用 k=2 增长因子的问题在于，每次扩展的新尺寸必然刚好大于之前分配的总和：
{% asset_img k=2.JPG k=2 %}
也就是说，之前分配的内存空间不可能被使用。这样对于缓存并不友好。最好把增长因子设为 1 < k < 2，例如 Folly 采用 1.5，RapidJSON 也是跟随采用 1.5：
{% asset_img k=1.5内存分配情况.JPG 内存分配情况 %}
可以看到，k = 1.5 在几次扩展之后，可以重用之前的内存空间。

## 插入/删除效率
由于是顺序容器，其插入/删除操作有移动元素的过程，故时间复杂度为 O(n)。
