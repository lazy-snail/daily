---
title: JVM-晚期运行期优化
date: 2018-04-27 19:15:39
categories:
tags: [Java, JVM]
---
Java 程序最初是通过解释器（Interpreter）进行解释执行的。而当 JVM 发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为 **“热点代码（Hot Spot Code）”**。为了提高热点代码的执行效率，在运行时，JVM 将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为 **即时编译器（Just In Time Compiler，JIT 编译器）**。
主流 JVM 一般同时包含解释器和编译器。它们各有优势：
* 当程序需要快速启动和执行时，解释器可以首先发挥作用，省去编译时间，立即执行；
* 在运行期间随着时间推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，从而获得更高的执行效率。
* 当运行环境中内存资源限制较大（如嵌入式系统），可以使用解释器执行以节约内存；反之可以使用编译器执行来提升效率；
* 解释器还作为编译器激进优化时的“逃生门”：深层次优化不成立时回退到解释状态继续执行；等
实际中，二者一半是配合工作。

### HotSpot 的分层编译（Tiiered Compilation）优化
根据编译器编译、优化的规模与耗时，划分出不同的编译层次：
* 第 0 层，程序解释执行，解释器不开启性能监控功能（Profiling），可触发第 1 层编译；
* 第 1 层（C1 编译），将字节码编译为本地代码，进行简单、可靠的优化，如有必要则加入性能监控的逻辑；
* 第 2 层/ 2层以上（C2 编译），将字节码编译为本地代码，会启用一些编译耗时较长的优化，甚至根据性能监控信息进行一些激进/不可靠的优化。

实施分层编译后，两个编译器 Client Compiler 和 Server Compiler 会同时工作，许多代码可能会被多次编译：用 Client Compiler 获取更高的编译速度，用 Server Compiler 获取更好的编译质量。

### 热点代码&触发条件
可见，热点代码有两类：
* 被多次调用的方法
* 被多次执行的循环体

两种情况都是以方法为粒度进行 JIT 编译。尽管后者编译动作是由循环体触发，但编译器仍以整个方法为编译对象。这种编译方式因为发生在方法执行过程中，因此形象地称之为 **栈上替换（On Stack Replacement，简称 OSR 编译，即方法栈帧还在栈上，方法就被替换了）。**

判断一段代码是不是热点代码，是不是需要触发 JIT，这样的行为成为热点探测（Hot Spot Detection）。目前常用的方法有两种：
* 基于采样的热点探测（Sample Based Hot Spot Detection）：JVM 周期性检查各个线程的栈顶，如果发现某个/某些方法经常出现在栈顶，那这个方法就是“热点方法”。该方法 **实现简单、高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可）**。而缺点是 **难以精确确认一个方法的热度：容易受到线程阻塞或其他外界因素影响而扰乱热点探测**。
* 基于计数器的热点探测（Counter Based Hot Spot Detection）：JVM 为每个方法（甚至代码块）建立计数器，统计方法的执行次数，超过特定阈值即认为它是“热点代码”。该方法 **统计结果相对精确和严谨**；但 **实现复杂：需要为每个方法建立并维护计数器，且不能直接获取方法的调用关系**。

### HotSpot 的实现（Client模式）
HotSpot 使用的是第二种方法，且为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。在确定了 JVM 运行参数后，这两个计数器都有一个确定的阈值，溢出就会触发 JIT 编译。
#### 方法调用计数器部分
方法调用计数器，就是上面的定义。其默认阈值在 Client 模式下是 1500 次，Server 模式下是 10000 次，可通过 -XX: CompileThreshold 配置。当一个方法被调用时，会先检查该方法是否已存在被编译过的版本，如果存在，优先使用它来执行，否则将该方法的调用计数器 +1，然后判断调用计数器与回边计数器之和是否超过方法调用计数器的阈值，如果超过则向 JIT 编译器提交一个该方法的代码编译请求。
不做任何设置情况下，执行引擎不会同步等待编译器请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译工作完成后，这个方法的调用入口地址会被系统自动改写成新的，下一次调用该方法时就会使用已编译的版本。
{% asset_img JVM-HotSpot方法调用计数器.png JVM-HotSpot热点探测 %}

**方法调用计数器的衰减**
不做任何设置情况下，方法调用计数器统计的不是方法被调用的绝对次数，而是一段时间内的次数：当超过一定的时间限度，如果该方法的调用次数仍不足以触发，那么方法调用计数器数值就要减半，这一过程称为 **方法调用计数器热度的衰减（Counter Decay）**，而这段时间就称为该方法的 **半衰周期（Counter Half Life Time）**。进行热度衰减的动作是在 JVM 进行 GC 时顺便进行的，可使用 -XX: UseCounterDecay 来关闭热度衰减，让方法调用计数器统计绝对次数。这样，只要程序运行时间足够长，大部分方法都会被编译成本地代码。还可以用 -XX: CounterHalfLifeTime 设置半衰周期的时间（秒）。

#### 回边计数器部分
**在字节码中遇到控制流向后跳转的指令称为“回边（Back Edge）”**。用于统计一个方法中循环体代码执行的次数（准确说是回边次数，比如空循环就不算控制流跳转，也不会被回边计数器统计）。显然，回边计数器是为了触发 OSR 编译。
回边计数器阈值计算方式与方法调用计数器阈值和 OSR 比率、解释器监控比率等有关，也和编译器模式（Client、Server）有关。
当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否已有编译好的版本，如果有，优先使用它来执行，否则就把回边计数器 +1，然后判断方法调用计数器与回边计数器之和是否超过回边计数器的阈值，如果超过则提交一个 OSR 编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。回边计数器没有热度衰减的过程，所以统计的是绝对次数。
{% asset_img JVM-HotSpo回边计数器.png JVM-HotSpo回边计数器 %}

Server VM 的 JIT 会更复杂一些，但流程总体大致如此。上述两种提交，也可以通过 -XX: BackgroundCompilation 配置来禁止后台编译，这样提交编译请求后，执行线程会等待编译完成，然后使用编译后的本地代码继续执行。

#### 后台编译过程
**Client Compiler**：简单快速的三段式编译器，主要关注点在于局部性的优化，放弃了许多耗时较长的全局优化手段。
1. 一个平台独立的前端将字节码构造成一种高级中间代码表示（High-Level Intermediate Representaion，HIR）。HIR使用静态单分配（Static Single Assignment，SSA）的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器会在字节码上完成一部分基础优化，如方法内联、常量传播等优化将会在字节码被构造成HIR之前完成。
2. 一个平台相关的后端从HIR中产生低级中间代码表示（Low-Level Intermediate Representation，LIR），而在此之前会在HIR上完成另外一些优化，如空值检查消除、范围检查消除等，以便让 HIR 达到更高效的代码表示形式。
3. 在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码。

{% asset_img Client-Compiler架构.PNG Client Compiler架构 %}

**Server Compiler**：专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，几乎能达到GNU C++编译器使用-O2参数时的优化强度，它会执行所有经典的优化动作，如无用代码消除（Dead Code Elimination）、循环展开（Loop Unrolling）、循环表达式外提（Loop ExpressionHoisting）、消除公共子表达式（Common Subexpression Elimination）、常量传播（Constant Propagation）、基本块重排序（Basic Block Reordering）等，还会实施一些与Java语言特性密切相关的优化技术，如范围检查消除（Range Check Elimination）、空值检查消除（Null Check Elimination，不过并非所有的空值检查消除都是
依赖编译器优化的，有一些是在代码运行过程中自动优化了）等。另外，还可能根据解释器或Client Compiler提供的性能监控信息，进行一些不稳定的激进优化，如守护内联（Guarded Inlining）、分支频率预测（BranchFrequency Prediction）等。本章的下半部分将会挑选上述的一部分优化手段进行分析和讲解。
Server Compiler的寄存器分配器是一个全局图着色分配器，它可以充分利用某些处理器架构（如RISC）上的大寄存器集合。以即时编译的标准来看，Server Compiler无疑是比较缓慢的，但它的编译速度依然远远超过传统的静态优化编译器，而且它相对于Client Compiler编译输出的代码质量有所提高，可以减少本地代码的执行时间，从而抵消了额外的编译时间开销，所以也有很多非服务端的应用选择使用Server模式的虚拟机运行。

JIT编译过程是一个虚拟机中最体现技术水平也是最复杂的部分。
