---
title: Java-Synchronized
date: 2018-05-26 14:19:58
categories: java
tags: [java, 并发]
---
[toc]
## synchronized
java中每个对象都可以作为锁：
* 对于普通同步方法，锁是当前实例对象；
* 对于静态同步方法，锁是当前类的 Class 对象；
* 对于同步方法块，锁是 Synchronized 括号中配置的对象。

当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。
一方面，该关键字实现原子性或者确定“临界区”，另一方面，保证状态修改的“内存可见性”。

## jvms 中关于代码块同步的描述
代码块同步使用 monitorenter 和 monitorexit 指令实现。monitorenter 指令是在编译后插入到同步代码块的开始位置，monitorexit 指令插入到方法结束处和异常处理处，jvm 要保证每个 monitorenter 必须有对应的 monitorexit 与之配对。任何对象都有一个 monitor 与之关联，当且仅当 monitor 被持有，它即处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获取对象的锁。
方法同步的实现细节与之有所差异，jvms 中也无详述，但同样也可以使用这两条指令来实现。

## 关于 java 对象头
Synchronized 使用的锁存放在 java 对象头里。如果对象是数组类型，jvm 用3个字宽（即3个word，在32位 jvm 中1字宽等于4字节，即32位）存储对象头，非数组对象使用2字宽存储对象头：
{% asset_img java对象头.png java对象头 %}

其中 mark word 的状态随着锁标志位的变化如下（默认为无锁状态）：
{% asset_img Synchronized锁状态.png Synchronized锁状态 %}

## 锁
java SE 1.6 引入了“偏向锁”和“轻量级锁”：以减少获得/释放锁带来的性能消耗。目前共有4种锁状态，级别从低到高：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。这几个状态会随着竞争情况的加剧而逐渐升级，但不可以降级，目的是为了提高获得锁和释放锁的效率。

### 轻级量锁
“轻量”是相对于使用 OS 互斥量来实现的传统锁而言的，**它并非用来代替重量级锁，而是在没有多线程竞争的前提下，减少传统的重量级锁的使用产生的性能消耗**。使用场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量锁升级为重量级锁。

#### 轻量级锁加锁过程
1. 代码进入同步块时，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），jvm 首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝，官方称之为 Displaced Mark Word；
2. 拷贝对象头中的 Mark Word 复制到锁记录中；
3. jvm 将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock record 里的owner 指针指向 object mark word。如果更新成功，则执行步骤（3），否则执行步骤（4）；
4. 更新操作成功，这个线程拥有该对象的锁，并且对象 Mark Word 的锁标志位设置为“00”，即此对象处于轻量级锁定状态；
5. 更新操作失败，jvm 首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁升级为重量级锁，锁标志的状态值变为“10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。

#### 轻量级锁释放过程
1. 通过 CAS 操作尝试把线程中复制的 Displaced Mark Word 对象替换当前的Mark Word；
2. 如果替换成功，整个同步过程完成；
3. 如果替换失败，说明有其他线程尝试过获取该锁（此时锁已升级），需要在释放锁的同时，唤醒被挂起的线程。

### 偏向锁
偏向锁的引入是为了在没有多线程竞争的情况下尽量减少不必要的轻量级锁执行，因为轻量级锁的获取/释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令。
可见，轻量级锁是 **在线程交替执行同步块时提高性能**，偏向锁是 **在只有一个线程执行同步块时进一步提高性能**。

#### 偏向锁获取过程
1. 访问 Mark Word 中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态；
2. 如果为可偏向状态，则测试线程 ID 是否指向当前线程：如果是，进入步骤（5），否则进入步骤（3）；
3. 如果线程 ID 并未指向当前线程，则通过 CAS 操作竞争锁。如果竞争成功，则将 Mark Word 中线程 ID 设置为当前线程 ID，然后执行（5）；如果竞争失败，执行（4）；
4. 如果 CAS 获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码；
5. 行同步代码。

#### 偏向锁释放过程
偏向锁只有遇到其他线程尝试竞争偏向锁时（上述获取过程的第4步），持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。

#### 锁转换
重量级锁、轻量级锁和偏向锁之间的转换
{% asset_img Synchronized锁转换.png Synchronized锁转换 %}

### 锁优化
#### 适应性自旋（Adaptive Spinning）
从轻量级锁获取的流程可见，当线程在获取轻量级锁的过程中执行 CAS 操作失败时，是要通过自旋来获取重量级锁的。但是，自旋是需要消耗 CPU 的，如果一直获取不到锁的话，那该线程就一直处于自旋状态。解决这个问题最简单的方法就是指定自旋的次数，比如循环10次，如果还没有获取到锁就进入阻塞状态。JDK 采用的方法是“适应性自旋”：如果线程成功自旋（获得锁），则下次自旋的次数会更多，如果失败，自旋的次数会减少。

#### 锁粗化（Lock Coarsening）
将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。
```java
public class StringBufferTest {
    StringBuffer stringBuffer = new StringBuffer();

    public void append(){
        stringBuffer.append("a");
        stringBuffer.append("b");
        stringBuffer.append("c");
    }
}
```
如果这里每次调用 stringBuffer.append 方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次 append 方法时进行加锁，最后一次 append 方法结束后进行解锁。

#### 锁消除（Lock Elimination）
删除不必要的加锁操作。根据代码逃逸技术，如果 jvm 判断出一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，也就无需加锁。
