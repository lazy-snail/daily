---
title: TCP
date: 2018-03-30 10:40:05
categories: CN
tags: CN
---
提供面向连接的、可靠的字节流服务。全双工，即能在两个方向上独立地进行传输。
通过超时重传、流量控制、检验和、失序重排等保证可靠等特性。

# 首部内容（20字节+选项内容）
{% asset_img TCP-header.PNG TCP 首部 %}
## 16 位源端口号
寻找发端应用程序。

## 16位 目的端口号
寻找收端应用程序。

## 32 位序号
Sequence Number。无符号循环，标识字节流。序号字段初始值（ISN）由发端主机选择，要发送的第一个字节序号为ISN+1：SYN 标志消耗了一个序号。接下来的发送会累加每个字节。

## 32 位确认序号
Acknowledgement Number，即 ack。无符号循环。包含发送确认的一端所期望收到的下一个序号，即上次已成功收到数据字节号 +1。只有 ack 字段为 1 时确认序号才有效。

## 4 位首部长度
首部中 32 bit 字的数目，即首部长度最多只能有 60 字节（20 + 最多 40 选项字段）。

## 6 位保留位

## 6 位标志位
* URG：紧急指针有效
* ACK：确认序号有效
* PSH：接收方应尽快将这个报文段交给应用层
* RST：重建连接
* SYN：同步序号用来发起一个连接
* FIN：发端完成发送任务

## 16 位接收窗口
提供流量控制。用于指示接收方愿意接收的字节数量。

## 16位检验和
覆盖整个 TCP 报文段。使用 12 字节伪首部，对每个 16 bit 进行反码求和。发端计算并存储，收端验证（全 1 为真）。

## 16 位紧急指针
URG 位为 1 时有效。

## 选项内容
最常见的是最长报文大小（MSS：Maximum Segment Size）。每个连接方通常在通信的第一个报文段中（SYN 中）指明这个选项：表明本端所能接收的最大长度的报文段（字节单位）。

# 滑动窗口协议
对应于首部的 16 位接收窗口内容。分为接收窗口、发送窗口。提供 TCP 的可靠性、流控制特性，也体现了 TCP 面向字节流的设计思路。

## 原理
{% asset_img TCP缓存数据分类.png TCP中的缓存数据分类 %}
首先，对于会话的发送方，任何时候在其发送缓存内的数据都可以分为 4 类：
1. Sent and Acknowledged：已收到 ack 确认的数据，这些数据已经发送成功并已经被确认的数据。即图中的前 31 个 bytes，这些数据位置在窗口之外，因为窗口内顺序最低的被确认之后，要移除窗口，实际上是窗口进行合拢，同时打开接收新的带发送的数据。
2. Send But Not Yet Acknowledged：已发送但还没收到 ack 的数据，这部分数据已经发送但还没有收到 ack，认为并没有完成发送，这个属于窗口内的数据。
3. Not Sent，Recipient Ready to Receive：在窗口中还没有发出的（接收方还有空间），是需要尽快发送的数据。接收方在首部“接收窗口”字段指明还能接收的字节数量，发送端设置这个值为当前窗口大小，而第二部分数据已经占据了一部分窗口空间（有可能已经占满窗口大小），所以这部分是需要马上发送的，因为接收方表明此时能够接收。
4. Not Sent，Recipient Not Ready to Receive：窗口以外的数据（接收方没空间），这些数据属于未发送，同时接收端也不期望发送的，因为这些数据已经超出了接收所能接收的范围。

窗口大小会根据接收端的首部携带值来动态调整。

## 移动
使用滑动窗口使得接收方不必确认每一个收到的分组。窗口两个边沿的相对运动（术语如下）将改变窗口大小：
* 合拢：窗口左边右移，发生在数据被发送和确认时；
* 张开：窗口右边右移，将允许发送更多的数据，发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时；
* 收缩：窗口右边左移，RFC强烈建议不要使用该操作。但TCP必须能够在某一端产生这种情况时进行处理。
不存在窗口左边左移的情况，因为确认序号是递增的。而如果收到一个指示窗口左移的 ACK，则它被认为是一个重复的 ACK，将被丢弃。
由接收方提供的窗口的大小通常可以由接受进程控制，这将影响 TCP 的性能。

## 扩展窗口大小
随着以太网等的发展，TCP 中 16 bit 窗口大小成为了一个限制，通过在首部的可选项字段增加一个选项，将窗口扩大为 32 bit（原首部 16 bit + 扩展 16 bit，不改变原首部内容）。

[TCP 的那些事儿](https://coolshell.cn/articles/11609.html)
[TCP-IP详解：滑动窗口](https://blog.csdn.net/wdscq1234/article/details/52444277)

# 连接建立/终止
## 三次握手
1. 请求端（通常为客户）发送一个 SYN 段指明客户打算连接的服务器的端口，以及初始序号（ISN: Initial Sequence Number）。这个 SYN 段为报文段 1；
2. 服务器发回包含服务器的初始序号的 SYN 报文段（报文段 2）作为允许连接的应答。同时，将确认序号设置为客户的 ISN+1 以对客户的 SYN 报文段进行确认。一个 SYN 将占用一个序号。并且，服务器会为该连接分配 TCP 缓存和变量。
3. 客户必须将确认序号设置为服务器的 ISN+1 以对服务器的 SYN 报文段进行确认（报文段 3）。同时为连接分配缓存和变量。此时连接已经建立，所以 SYN 置为 0（以后的都为 0），并且该阶段可以在报文段负载中携带数据。
{% asset_img 三次握手.png 三次握手过程 %}
这三个报文段完成连接的建立。这个过程也称三次握手（three-way handshake）。

### WHY
**为什么需要初始序号？为什么是 3 次而不是 2 或者 4 次**？
初始序列号随机产生首先是出于安全性考虑：如果非随机初始序列号，黑客很容易获取到该值，从而伪造序列号进行攻击；其次，如果硬编码初始序号，在连接过程中出现中断、滞留以及频繁连接等情况时，可能会因为序列号的问题接收到错误连接/已经过时的旧连接上的错误数据报。
假定只有两次握手：第一次 A 发起连接请求，第二次 B 发送确认请求以及本方向上的连接初始序号，到此完成连接，问题是此时 A 还没有确认 B 的初始序号，即 A 和 B 还没有就 B 的初始序号达成一致。同理四次握手的情况：A 发起连接请求，B 确认，B 发起连接请求，A 确认，这个过程中的第二次、第三次可以合并执行，即三次完成，可以提高连接的速度和效率。三次而非二或者四次同时保证了数据能够可靠传输和提高传输效率。

### SYN 攻击
在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 Syn_RECV 状态.当收到 ACK 后，服务器转入 ESTABLISHED 状态。
SYN 攻击就是攻击端在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 SYN 包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求被丢弃，使得目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。
SYN 攻击是一个典型的 DDos 攻击。检测 SYN 攻击非常容易：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。在 Linux 下可以如下命令检测是否被 SYN 攻击：
netstat -n -p TCP | grep SYN_RECV
一般较新的 TCP/IP 协议栈都对这一过程进行修正来防范 SYN 攻击：修改 TCP 协议实现。主要方法有 SynAttackProtect 保护机制、SYN cookies 技术、增加最大半连接和缩短超时时间等。但是它们也不能完全防范 SYN 攻击。

[参考](https://www.cnblogs.com/zmlctt/p/3690998.html)

## 四次挥手
建立一个连接需要三次握手，而终止一个连接需要四次握手（也称四次挥手），这是由 TCP 的半关闭（half-close）造成的：一个 TCP 连接是全双工（数据能在两个方向上同时传递）的，因此每个方向必须单独地进行关闭。具体原则就是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向上的连接。当一端收到 FIN，它必须通知应用层另一端已经终止了那个方向上的数据传送。发送 FIN 通常是应用层进行关闭的结果。
1. 一端发送含有置位 FIN（和 SYN 一样，一个 FIN 将占用一个序号）的报文段；
2. 另一端收到后，将确认序号设置为收到序号 +1 发回 ACK，同时传送给应用程序一个文件结束符，从而关闭该文件传送连接（主动关闭）；
3. 当另一端也完成了所有操作后，同样发送一个 FIN 报文段给一端；
4. 一端发回确认序号 ACK，关闭连接。
{% asset_img 四次挥手.jpg 四次挥手过程 %}
这四个报文段完成连接的双向关闭。这个过程也称四次挥手（four-way handshake）。

# RTT
RTT，Round-Trip Time，往返时间。超时与重传中最重要的部分是对一个给定连接的往返时间的测量。由于路由器和网络流量均会变化，RTT 可能也会经常变化，TCP 应该跟踪这些变化并相应地改变其超时时间。

典型的估计方法：
R ← αR + (1 - α)M
M为前一个估计，R为当前测量，一般 α 取 1/8。

除了测量RTT，一般还会测量RTT偏差值：DevRTT，用于估算R一般会偏离M的程度：
DevRTT ← (1 - β)DevRTT + β|R - M|
同样是指数加权移动平均（EWMA）。β推荐值为 1/4。

超时间隔：一般设置为
TimeoutInterval = R + 4·DevRTT

# 拥塞控制
TCP 的拥控方法简单来说是：让每个发送方根据所感知到的当前网络拥塞程度来限制其向连接发送流量（报文段）的速率。如果感知到线路不怎么拥塞，则发送方增加发送速率，vice verse。问题来了：
* 一个发送方如何感知线路上是否拥塞？
* 当感知到拥塞，如何限制发送速率，采用什么算法改变发送速率？

这涉及到 TCP 拥控实现中的三部分内容：慢启动、拥塞避免、快速重传和快速恢复。
首先是几个窗口概念。

## cwnd

## rwnd


## 慢启动 
通过观察“新分组进入网络的速率应该与另一端返回确认的速率相同”而进行工作。
慢启动为发送方的 TCP 增加了一个“拥塞窗口（Congestion Window，即 cwnd）”，建立连接之初，cwnd 被置为 1 个报文段，（即另一端通告的报文段大小），发送并等待第一个确认；当该确认到达，发送方将报文段 +1，并发送两个报文段，等待这两个的确认；当确认到达，对每个确认增加一个报文段，即此时是 cwnd 为 4；...这是一种指数增加的关系。因此，TCP 发送速率起始慢，但在慢启动阶段以指数增长。

## 拥塞避免
发生拥塞时，有超时/收到重复确认，慢启动阈值（ssthresh）被置为 cwnd 的一半，结束慢启动并将 TCP 转移到拥塞避免模式（注意，如果是超时引起的拥塞，则将 cwnd 置为 1，继续慢启动到 ssthresh）。拥塞避免状态下，TCP 会更为谨慎地选择增加 cwnd：每收到一个确认时将 cwnd 增加（1/cwnd），即希望在一个往返时间内最多为 cwnd 增加一个报文段。与慢启动阶段的指数增加相比，这是一种加性/线性增长（additive increase）。

## 快速重传和快速恢复
如果连续收到三个重复确认，则认为（很大可能）报文段丢失了，此时重传该数据报文段而无须等待超时定时器，这是快速重传算法。紧接着不是进入慢启动模式而是拥塞避免模式，这就是快速恢复算法。
快速恢复是 TCP 推荐而非必需的构件。较新的 TCP 版本如 Reno 使用了快速恢复算法。

## 几个定时器（Timer）

### 坚持定时器（Persist Timer）
TCP 通过窗口大小进行流量控制，接收方窗口大小为 0（发送方确认该值）时，发送方将不再发送携带数据的报文段而是等待非0窗口大小的 ACK 到来。考虑到：接收方将窗口大小置为非 0，但该确认并未到达（即发生丢失），双方有可能因为等待对方而使连接终止。

### 保活定时器（Keep Alive）
连接可以在中间路由器崩溃、重启等各种情况下（只要两端主机没有重启）保持数小时甚至数月。非 TCP 规范的一部分。
