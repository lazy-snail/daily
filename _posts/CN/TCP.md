---
title: TCP
date: 2018-03-30 10:40:05
categories: CN
tags: CN
---

#### 服务
提供面向连接的、可靠的字节流服务。全双工，即能在两个方向上独立地进行传输。

#### 特点
超时重传、流量控制、检验和、失序重排等。

#### 首部内容（20字节+选项内容）
{% asset_img TCP-header.gif TCP 首部 %}

* 16位源端口号，16位目的端口号：寻找发端、收端应用程序；
* 32位序号：无符号循环，标识字节流。序号字段初始值（ISN）由发端主机选择，要发送的第一个字节序号为ISN+1：SYN标志消耗了一个序号。接下来的发送会累加每个字节；
* 32位确认序号：无符号循环。包含发送确认的一端所期望收到的下一个序号，即上次已成功收到数据字节号+1。只有ACK字段为1时确认序号才有效。
* 4位首部长度：首部中32bit字的数目，即首部长度最多只能有60字节（20+最多40选项字段）。
* 6位保留位。
* 6位标志位：
> 1. URG：紧急指针有效
> 2. ACK：确认序号有效
> 3. PSH：接收方应尽快将这个报文段交给应用层
> 4. RST：重建连接
> 5. SYN：同步序号用来发起一个连接
> 6. FIN：发端完成发送任务。

* 16位窗口大小：提供流量控制。可变。
* 16位检验和：覆盖整个TCP报文段。使用12字节伪首部，对每个16bit进行反码求和。发端计算并存储，收端验证（全1为真）。
* 16位紧急指针：URG位为1时有效。
* 选项内容：
最常见的是最长报文大小（MSS：Maximum Segment Size）。每个连接方通常在通信的第一个报文段中（SYN中）指明这个选项：表明本端所能接收的最大长度的报文段（字节单位）。

#### 建立连接（三次握手）
> 1. 请求端（通常为客户）发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号（ISN: Initial Sequence Number）。这个SYN段为报文段1；
> 2. 服务器发回包含服务器的初始序号的SYN报文段（报文段2）作为允许连接的应答。同时，将确认序号设置为客户的ISN+1以对客户的SYN报文段进行确认。一个SYN将占用一个序号。并且，服务器会为该连接分配TCP缓存和变量。
> 3. 客户必须将确认序号设置为服务器的ISN+1以对服务器的SYN报文段进行确认（报文段3）。同时为连接分配缓存和变量。此时连接已经建立，所以SYN置为0（以后的都为0），并且该阶段可以在报文段负载中携带数据。

这三个报文段完成连接的建立。这个过程也称三次握手（three-way handshake）。

> __思考__
> _：为什么需要初始序号？为什么是3次而不是2或者4次？_
> __解释：__
> _初始序列号随机产生首先是出于安全性考虑：如果非随机初始序列号，黑客很容易获取到该值，从而伪造序列号进行攻击；其次，如果硬编码初始序号，在连接过程中出现中断、滞留以及频繁连接等情况时，可能会因为序列号的问题接收到错误连接/已经过时的旧连接上的错误数据报。_
>_假定只有两次握手：第一次A发起连接请求，第二次B发送确认请求以及本方向上的连接初始序号，到此完成连接，问题是此时A还没有确认B的初始序号，即A和B还没有就B的初始序号达成一致。同理四次握手的情况：A发起连接请求，B确认，B发起连接请求，A确认，这个过程中的第二次、第三次可以合并执行，即三次完成，可以提高连接的速度和效率。三次而非二或者四次同时保证了数据能够可靠传输和提高传输效率。_

#### 终止连接（四次挥手）
建立一个连接需要三次握手，而终止一个连接需要四次握手（也称四次挥手），这是由TCP的半关闭（half-close）造成的：一个TCP连接是全双工（数据能在两个方向上同时传递）的，因此每个方向必须单独地进行关闭。具体原则就是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向上的连接。当一端收到FIN，它必须通知应用层另一端已经终止了那个方向上的数据传送。发送FIN通常是应用层进行关闭的结果。
> 1. 一端发送含有置位FIN（和SYN一样，一个FIN将占用一个序号）的报文段；
> 2. 另一端收到后，将确认序号设置为收到序号+1发回ACK，同时传送给应用程序一个文件结束符，从而关闭该文件传送连接（主动关闭）；
> 3. 当另一端也完成了所有操作后，同样发送一个FIN报文段给一端；
> 4. 一端发回确认序号ACK，关闭连接。

这四个报文段完成连接的双向关闭。这个过程也称四次挥手（four-way handshake）。

#### RTT
超时与重传中最重要的部分是对一个给定连接的往返时间（RTT）的测量。由于路由器和网络流量均会变化，RTT可能也会经常变化，TCP应该跟踪这些变化并相应地改变其超时时间。

典型的估计方法：
R ← αR + (1 - α)M
M为前一个估计，R为当前测量，一般 α 取 1/8。

除了测量RTT，一般还会测量RTT偏差值：DevRTT，用于估算R一般会偏离M的程度：
DevRTT ← (1 - β)DevRTT + β|R - M|
同样是指数加权移动平均（EWMA）。β推荐值为 1/4。

超时间隔：一般设置为
TimeoutInterval = R + 4·DevRTT


#### 滑动窗口
使用滑动窗口使得接收方不必确认每一个收到的分组。窗口两个边沿的相对运动（术语如下）将改变窗口大小：
1. 合拢：窗口左边右移，发生在数据被发送和确认时；
2. 张开：窗口右边右移，将允许发送更多的数据，发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时；
3. 收缩：窗口右边左移，RFC强烈建议不要使用该操作。但TCP必须能够在某一端产生这种情况时进行处理。
不存在窗口左边左移的情况，因为确认序号是递增的。而如果收到一个指示窗口左移的ACK，则它被认为是一个重复的ACK，将被丢弃。
由接收方提供的窗口的大小通常可以由接受进程控制，这将影响TCP的性能。
随着以太网等的发展，TCP中16bit窗口大小成为了一个限制，通过在首部的选项区增加一个选项，将窗口扩大为32bit（原首部16bit+扩展16bit，不改变原首部内容）。

#### 拥塞控制算法
包括三部分主要内容：
##### 1. 慢启动 通过观察“新分组进入网络的速率应该与另一端返回确认的速率相同”而进行工作。
慢启动为发送方的TCP增加了一个“拥塞窗口（Congestion Window 简记 cwnd）”，建立连接之初，cwnd被置为1个报文段，（即另一端通告的报文段大小），发送并等待第一个确认；当该确认到达，发送方将报文段加一，并发送两个报文段，等待这两个的确认；当确认到达，对每个确认增加一个报文段，即此时是cwnd为4；...这是一种指数增加的关系。因此，TCP发送速率起始慢，但在慢启动阶段以指数增长。

###### 2. 拥塞避免
发生拥塞时，有超时/收到重复确认，慢启动阈值（ssthresh）被置为cwnd的一半，结束慢启动并将TCP转移到拥塞避免模式（注意，如果是超时引起的拥塞，则将cwnd置为1，继续慢启动到ssthresh）。拥塞避免状态下，TCP会更为谨慎地选择增加cwnd：每收到一个确认时将cwnd增加（1/cwnd），即希望在一个往返时间内最多为cwnd增加一个报文段。与慢启动阶段的指数增加相比，这是一种加性/线性增长（additive increase）。

###### 3. 快速重传&快速恢复
如果连续收到三个重复确认，则认为（很大可能）报文段丢失了，此时重传该数据报文段而无须等待超时定时器，这是快速重传算法。紧接着不是进入慢启动模式而是拥塞避免模式，这就是快速恢复算法。
快速恢复是TCP推荐而非必需的构件。较新的TCP版本如Reno，就综合了快速恢复算法。

#### 几个定时器（Timer）
1. 坚持定时器（Persist Timer）
TCP通过窗口大小进行流量控制，接收方窗口大小为0（发送方确认该值）时，发送方将不再发送携带数据的报文段而是等待非0窗口大小的ACK到来。考虑到：接收方将窗口大小置为非0，但该确认并未到达（即发生丢失），双方有可能因为等待对方而使连接终止。

2. 保活定时器（Keep Alive）
连接可以在中间路由器崩溃、重启等各种情况下（只要两端主机没有重启）保持数小时甚至数月。非TCP规范的一部分。
