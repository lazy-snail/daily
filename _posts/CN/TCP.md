---
title: TCP
date: 2018-03-30 10:40:05
categories: CN
tags: CN
---
提供面向连接的、可靠的字节流服务。全双工，即能在两个方向上独立地进行传输。通过超时重传、流量控制、检验和、失序重排等保证可靠等特性。
**数据传输过程概述**
TCP 连接建立好之后，进程通过套接字传递数据流，数据流经过套接字之后，就转由 TCP 控制。TCP 将数据流引导到该连接的发送缓存（send buffer）中，并时不时从发送缓存取出一块数据，_TCP 规范中并未规定何时发送缓存中的数据_。TCP 可从缓存中取出并放入报文段中的数据量受限于最大报文段长度（Maximum Segment Size，MSS），MSS 通常根据最初确定的由本地发送主机发送的最大链路层帧长度（Maximum Transmission Unit，MTU）来这是。设置 MSS 要保证一个 TCP 报文段加上 TCP 首部（通常 40 字节）将适合单个链路层帧。以太网和 PPP 链路层协议具有 1500 字节的 MTU，因此 MSS 典型值为 1460 字节。注意 MSS 并不包括 TCP/IP 首部，简单理解成：MSS + TCP 首部 = TCP 报文段长度。

# 首部内容
20字节+选项内容：
{% asset_img TCP-header.PNG TCP 首部 %}
## 16 位源端口号
寻找发端应用程序。

## 16位 目的端口号
寻找收端应用程序。

## 32 位序号
Sequence Number。无符号循环，标识字节流。序号字段初始值（ISN）由发端主机选择，要发送的第一个字节序号为ISN+1：SYN 标志消耗了一个序号。接下来的发送会累加每个字节。

## 32 位确认序号
Acknowledgement Number，即 ack。无符号循环。包含发送确认的一端所期望收到的下一个序号，即上次已成功收到数据字节号 +1。只有 ack 字段为 1 时确认序号才有效。

## 4 位首部长度
首部中 32 bit 字的数目，即首部长度最多只能有 60 字节（20 + 最多 40 选项字段）。

## 6 位保留位

## 6 位标志位
* URG：紧急指针有效
TCP 提供了“紧急方式（urgent mode）”，它使一端可以告诉另一端有些具有某种方式的“紧急数据”已经放置在普通的数据流中，另一端被通知这个紧急数据已经被放置在普通数据流中，由接收方决定如何处理。使用方式是该位置 1，配合“紧急指针”设置的正偏移量，该偏移量 + ack，即得到紧急数据的最后一个字节的序号。
* ACK：确认序号有效
* PSH：接收方应尽快将这个报文段交给应用层
该标志位通知接收方将所收到的数据全部提交给接收进程，即接收到的数据不继续缓存在 TCP 接收缓存中，而是直接提交给进程处理。
* RST：重建连接
* SYN：同步序号用来发起一个连接
* FIN：发端完成发送任务

## 16 位接收窗口
提供流量控制。用于指示接收方愿意接收的字节数量。

## 16位检验和
覆盖整个 TCP 报文段。使用 12 字节伪首部，对每个 16 bit 进行反码求和。发端计算并存储，收端验证（全 1 为真）。

## 16 位紧急指针
URG 位为 1 时有效。

## 选项内容
最常见的是最长报文大小（MSS：Maximum Segment Size）。每个连接方通常在通信的第一个报文段中（SYN 中）指明这个选项：表明本端所能接收的最大长度的报文段（字节单位）。

# 连接建立/终止
## 三次握手
1. 请求端（通常为客户）发送一个 SYN 段指明客户打算连接的服务器的端口，以及初始序号（ISN: Initial Sequence Number）。这个 SYN 段为报文段 1；
2. 服务器发回包含服务器的初始序号的 SYN 报文段（报文段 2）作为允许连接的应答。同时，将确认序号设置为客户的 ISN+1 以对客户的 SYN 报文段进行确认。一个 SYN 将占用一个序号。并且，服务器会为该连接分配 TCP 缓存和变量。
3. 客户必须将确认序号设置为服务器的 ISN+1 以对服务器的 SYN 报文段进行确认（报文段 3）。同时为连接分配缓存和变量。此时连接已经建立，所以 SYN 置为 0（以后的都为 0），并且该阶段可以在报文段负载中携带数据。
{% asset_img 三次握手.png 三次握手过程 %}
这三个报文段完成连接的建立。这个过程也称三次握手（three-way handshake）。

### WHY
**为什么需要初始序号？为什么是 3 次而不是 2 或者 4 次**？
初始序列号随机产生首先是出于安全性考虑：如果非随机初始序列号，黑客很容易获取到该值，从而伪造序列号进行攻击；其次，如果硬编码初始序号，在连接过程中出现中断、滞留以及频繁连接等情况时，可能会因为序列号的问题接收到错误连接/已经过时的旧连接上的错误数据报。
假定只有两次握手：第一次 A 发起连接请求，第二次 B 发送确认请求以及本方向上的连接初始序号，到此完成连接，问题是此时 A 还没有确认 B 的初始序号，即 A 和 B 还没有就 B 的初始序号达成一致。同理四次握手的情况：A 发起连接请求，B 确认，B 发起连接请求，A 确认，这个过程中的第二次、第三次可以合并执行，即三次完成，可以提高连接的速度和效率。三次而非二或者四次同时保证了数据能够可靠传输和提高传输效率。

### SYN 攻击
在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 Syn_RECV 状态.当收到 ACK 后，服务器转入 ESTABLISHED 状态。
SYN 攻击就是攻击端在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 SYN 包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求被丢弃，使得目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。
SYN 攻击是一个典型的 DDos 攻击。检测 SYN 攻击非常容易：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。在 Linux 下可以如下命令检测是否被 SYN 攻击：
netstat -n -p TCP | grep SYN_RECV
一般较新的 TCP/IP 协议栈都对这一过程进行修正来防范 SYN 攻击：修改 TCP 协议实现。主要方法有 SynAttackProtect 保护机制、SYN cookies 技术、增加最大半连接和缩短超时时间等。但是它们也不能完全防范 SYN 攻击。

[参考](https://www.cnblogs.com/zmlctt/p/3690998.html)

## 四次挥手
建立一个连接需要三次握手，而终止一个连接需要四次握手（也称四次挥手），这是由 TCP 的半关闭（half-close）造成的：一个 TCP 连接是全双工（数据能在两个方向上同时传递）的，因此每个方向必须单独地进行关闭。具体原则就是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向上的连接。当一端收到 FIN，它必须通知应用层另一端已经终止了那个方向上的数据传送。发送 FIN 通常是应用层进行关闭的结果。
1. 一端发送含有置位 FIN（和 SYN 一样，一个 FIN 将占用一个序号）的报文段；
2. 另一端收到后，将确认序号设置为收到序号 +1 发回 ACK，同时传送给应用程序一个文件结束符，从而关闭该文件传送连接（主动关闭）；
3. 当另一端也完成了所有操作后，同样发送一个 FIN 报文段给一端；
4. 一端发回确认序号 ACK，关闭连接。
{% asset_img 四次挥手.PNG 四次挥手过程 %}
这四个报文段完成连接的双向关闭。这个过程也称四次挥手（four-way handshake）。
注意连接双方不同状态的变化。这里用主动关闭方（一般为 Client）和被动方（一般为 Server）描述。

### FIN_WAIT_1
FIN_WAIT，从名字上来看，就是等待对方的 FIN 报文，两者有所区别。FIN_WAIT_1 是主动发起关闭方才会出现的状态。主动关闭方发送关闭请求，即发送置位 FIN 的报文段，随即进入 FIN_WAIT_1 状态。当收到对方的 ack，进入 FIN_WAIT_2 状态。

### FIN_WAIT_2
当收到被动方发回的连接关闭请求的 ack，主动方进入 FIN_WAIT_2 状态。此时一般的场景应该是等待被动方的应用层意识到对方已经请求并被确认关闭该连接（半关闭），很快被动方应用层也会请求关闭。也可能仅仅是主动方想进入半关闭状态，主动方没有要发送的数据了，但还需要继续接收数据。
FIN_WAIT_2 持续时间为从收到被动方 ack 到收到被动方发起关闭请求（即 FIN 报文段）的这段时间。

### CLOSE_WAIT
被动方等待关闭。被动方接收到对方发送的 FIN 报文段，予以回应的同时，将自己的状态由 ESTABLISHED 转变为 CLOSE_WAIT。此时需要做的工作是确认是否还有数据要发送给对方，如果有则继续发送，否则也应该发起关闭连接请求。

### LAST_ACK
被动方发出 FIN 报文段后即进入该状态，等待最后一个 ack 到来。

### TIME_WAIT
主动关闭 TCP 连接的一方会进入 TIME_WAIT 状态，也称 2MSL 等待状态，并且维持该状态时长为 2 * MSL。
**为什么是 2MSL**：
可靠安全地关闭全双工 TCP 连接。如果网络有拥塞，主动方最后一个 ack 并没有被正确接收，那么被动方会重传置位了 FIN 的 ack，此时由于主动方还没有真正关闭，也就有时间处理该重传。而如果等待时间不足，连接在被动方的重传 FIN 在到达前就已经彻底关闭，此时，首先是被动方没有正确关闭；还有需要考虑这种情况：关闭后主动方马上又和该被动方建立起一个 TCP 连接，那么，之前的 TCP 连接的重传过来的置位了 FIN 的 ack 会对本次连接造成影响。

# 滑动窗口协议
滑动窗口，即首部中的 16 位 Receive Window，也称接收窗口，简写“rwnd”。分为接收窗口、发送窗口。提供 TCP 的可靠性、流控制特性，也体现了 TCP 面向字节流的设计思路。
滑动窗口的主要作用是 TCP 流量控制：让发送方以合适的速率发送报文段，以使接收方有能力接收数据。双方各自维护一个滑动窗口。

## 原理
{% asset_img TCP缓存数据分类.png TCP中的缓存数据分类 %}
首先，对于会话的发送方，任何时候在其发送缓存内的数据都可以分为 4 类：
1. Sent and Acknowledged：已收到 ack 确认的数据，这些数据已经发送成功并已经被确认的数据。即图中的前 31 个 bytes，这些数据位置在窗口之外，因为窗口内顺序最低的被确认之后，要移除窗口，实际上是窗口进行合拢，同时打开接收新的带发送的数据。
2. Send But Not Yet Acknowledged：已发送但还没收到 ack 的数据，这部分数据已经发送但还没有收到 ack，认为并没有完成发送，这个属于窗口内的数据。
3. Not Sent，Recipient Ready to Receive：在窗口中还没有发出的（接收方还有空间），是需要尽快发送的数据。接收方在首部“接收窗口”字段指明还能接收的字节数量，发送端设置这个值为当前窗口大小，而第二部分数据已经占据了一部分窗口空间（有可能已经占满窗口大小），所以这部分是需要马上发送的，因为接收方表明此时能够接收。
4. Not Sent，Recipient Not Ready to Receive：窗口以外的数据（接收方没空间），这些数据属于未发送，同时接收端也不期望发送的，因为这些数据已经超出了接收所能接收的范围。

窗口大小会根据接收端的首部携带值来动态调整。

## 移动
使用滑动窗口使得接收方不必确认每一个收到的分组。窗口两个边沿的相对运动（术语如下）将改变窗口大小：
* 合拢：窗口左边右移，发生在数据被发送和确认时；
* 张开：窗口右边右移，将允许发送更多的数据，发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时；
* 收缩：窗口右边左移，RFC强烈建议不要使用该操作。但TCP必须能够在某一端产生这种情况时进行处理。
不存在窗口左边左移的情况，因为确认序号是递增的。而如果收到一个指示窗口左移的 ACK，则它被认为是一个重复的 ACK，将被丢弃。
由接收方提供的窗口的大小通常可以由接受进程控制，这将影响 TCP 的性能。

## 扩展窗口大小
随着以太网等的发展，TCP 中 16 bit 窗口大小成为了一个限制，通过在首部的可选项字段增加一个选项，将窗口扩大为 32 bit（原首部 16 bit + 扩展 16 bit，不改变原首部内容）。

[TCP 的那些事儿](https://coolshell.cn/articles/11609.html)
[TCP-IP详解：滑动窗口](https://blog.csdn.net/wdscq1234/article/details/52444277)
[滑动窗口具体是怎样控制流量的](http://zhihu.com/question/32255109/answer/68558623)

# 超时重传
使用 RTO 计时器实现超时重传机制。在时限内如果没有收到报文段的确认回复，则重新发送该数据段。

# 拥塞控制
TCP 的拥控方法简单来说是：让每个发送方根据所感知到的当前网络拥塞程度来限制其向连接发送流量（报文段）的速率。如果感知到线路不怎么拥塞，则发送方增加发送速率，vice verse。问题来了：
* 一个发送方如何感知线路上是否拥塞？
* 当感知到拥塞，如何限制发送速率，采用什么算法改变发送速率？

TCP 拥塞控制算法中包含 3 个主要部分：慢启动、拥塞避免、快速重传和快速恢复。
首先是一些概念。

## RTT
RTT，Round-Trip Time，往返时间。超时与重传中最重要的部分是对一个给定连接的往返时间的测量。由于路由器和网络流量均会变化，RTT 可能也会经常变化，TCP 应该跟踪这些变化并相应地改变其超时时间。

典型的估计方法：
R ← αR + (1 - α)M
M为前一个估计，R为当前测量，一般 α 取 1/8。

除了测量RTT，一般还会测量RTT偏差值：DevRTT，用于估算R一般会偏离M的程度：
DevRTT ← (1 - β)DevRTT + β|R - M|
同样是指数加权移动平均（EWMA）。β推荐值为 1/4。

超时间隔：一般设置为
TimeoutInterval = R + 4·DevRTT

## cwnd
congestion window，简写“cwnd”，拥塞窗口。TCP 连接的每一端都由一个接收缓存、一个发送缓存和一些变量（LastByteRead、rwnd 等）组成。运行在发送方的 TCP 拥塞控制机制跟踪一个额外的变量，即拥塞窗口。它对一个 **TCP 发送方能向网络中发送流量的速率进行限制**。发送方取 cwnd 和 rwnd 中的最小值最为发送数据量的上限，可见滑动窗口不仅在流量控制中很重要，在拥塞控制中依然有作用。

## 慢启动 
通过观察“新分组进入网络的速率应该与另一端返回确认的速率相同”而进行工作。
{ asset_img 慢启动.PNG 慢启动 %}
慢启动为发送方的 TCP 增加了一个拥塞窗口。TCP 建立链接时，cwnd 一般被置为 1 个报文段大小（也有的说是 1 个 MSS，基本相同，后续采用 MSS），即为初始发送数据的速率。发送端发送并等待第一个确认，当该确认到达，发送端设置 cwnd = cwnd * 2，即 cwnd 大小为 2 个单位。同样发送这些数据，并等待这两个的确认；当确认到达，**对每个确认增加一个报文段（结果依然是 cwnd * 2）**，即此时是 cwnd 为 4；...这是一种指数增加的关系。因此，TCP 发送速率起始慢，但在慢启动阶段以指数增长。所以可以理解成，“慢启动”名字的由来，是为了解决“TCP 连接初始阶段发送数据过慢的问题”。

### 结束慢启动
显然，网络环境必然存在一个阈值使得慢启动在一段时间后造成网络拥堵。而结束慢启动的方式一般是进入拥塞避免。

### 检测拥塞发生
简单来说有些指标会隐含“线路可能拥堵”：丢包和重复 ack、超时。
重复确认（一般达到 3 次）意味着，该 ack 代表的序列号的前一部分数据没有正常到达接收端（否则应该收到确认），也就是发生了丢包，这种情况可以看作线路拥堵的征兆。
另一种情况是超时。拥控机制使用 RTO 记录包传输的时限，超过该时限则认为拥塞发生。

## 拥塞避免
除了 cwnd 外，拥控机制里还有一个变量跟慢启动与拥塞避免关系密切：sshresh（Slow-Start Threshold，慢启动阈值的速记）。确认发生拥塞时，ssthresh 被置为 cwnd 的一半，同时结束慢启动并将 TCP 转移到拥塞避免模式。该状态下，TCP 会更为谨慎地选择增加 cwnd：每收到一个确认时将 cwnd 增加（1/cwnd），即在 1 个 RTT 内最多为 cwnd 增加 1 个 MSS。可见，与慢启动阶段的乘性增/指数增加相比，这是一种加性增/线性增长（additive increase）。

## 快速重传和快速恢复
超时重传的问题在于有可能提前（重传定时器 RTO 还未停止计时）发现丢包，典型的是收到多次（一般为 3 次）重复 ack，这种情况可以看作是丢包发生，此时直接选择重传数据段，而非继续等待 RTO 溢出，这就叫快速重传。而快速重传完成后，恢复到拥塞避免状态，而非慢启动状态，这就是快速恢复。
一般快速重传和快速恢复配合使用。具体的拥控实现有所不同。

## 4 个定时器（Timer）
### 重传定时器
Retransmission TimeOut，TRO。重传超时时间的计算跟 RTT 相关，动态调整，用于指示“超过该时限未收到确认则可能发生丢包”。

### 坚持定时器
Persist Timer。TCP 通过窗口大小进行流量控制，接收方窗口大小为 0（发送方确认该值）时，发送方将不再发送携带数据的报文段而是等待非0窗口大小的 ACK 到来。考虑到：接收方将窗口大小置为非 0，但该确认并未到达（即发生丢失），双方有可能因为等待对方而使连接终止。

### 保活定时器
Keep Alive。连接可以在中间路由器崩溃、重启等各种情况下（只要两端主机没有重启）保持数小时甚至数月。非 TCP 规范的一部分。

### 2MSL 定时器
MSL，Maximum Segment Lifetime，最长报文段寿命：任何报文段在网络上存活的最长时间，超过这个时间报文将被丢弃。Linux 中 MSL 固定为 30s，RFC-793 定义 MSL 为 2min。而 2MSL 定时器（2 倍 MSL 时间）主要作用就是 TCP 主动发起关闭请求的一端在发送最后一个 ack 后进入 TIME_WAIT 状态的计时，即 2MSL 后关闭该状态。
