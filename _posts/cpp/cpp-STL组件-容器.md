---
title: cpp-STL组件-容器
date: 2018-05-18 13:33:10
categories:
tags:
---
[toc]
# 容器，置物之所也
常用的数据结构不外乎 array（数组）、list（链表）、tree（树）、stack（栈）、queue（队列）、hash table（散列表）、set（集合）、map（映射表）等。根据数据在容器中的排列特性，这些数据结构分为序列式（sequence）和关联式（associative）两种。

## 序列式容器
所谓序列式容器，其中的元素都可序（ordered），但未必有序（sorted）。有以下种类：

### array
C++ 内置（build-in）序列式容器，使用静态连续空间，即，一旦声明就不能改变大小；

### vector
与 array 十分相似，差别在于空间运用的灵活性，vector使用动态空间，随着元素的加入，内部可以自行扩充空间以容纳新元素。实现中的技术在于 **对大小的控制和重新配置时的数据移动效率**。

#### 容量（capacity）
为降低空间配置时的速度成本，vector 实际配置的大小可能比客户端需求量更大一些，以备将来可能的扩充。这便是容量的概念。即，一个 vector 的容量（capacity）永远不小于其大小（size）。

#### 迭代器
连续线性空间可以直接使用普通指针作为迭代器，而不论其元素类型。即提供 Random Access Iterator。vector 维护3个指针迭代器：
1. start：目前使用空间的头；
2. finish：目前使用空间的尾；
3. 目前可用空间的尾。

使用以上3个迭代器，即可轻松提供首尾标示、大小、容量、空容器判断、下标（[]）运算符、最前/后端元素值等功能。注意，插入/删除会导致原本的迭代器失效：位置会发生变化。

### list
STL list 是一个双向链表（double linked-list），采用非线性空间，每插入/删除一个元素就相应配置/释放一个元素空间，即，精准使用空间不浪费。且 **对于任意位置元素插入/删除，都是常数O(1)时间**。

#### 迭代器
具备前移、后移的能力，是 Bidirectional Iterators。和 vector 的迭代器不同，其插入/删除操作不会造成原有的迭代器失效，仅仅影响被操作元素（和前后元素）的迭代器，其他位置不受影响。

### deque
vector 是单向开口的连续线性空间，而 deque 是一种双向开口的连续线性空间。所谓双向开口：可以在头尾两端分别做元素插入/删除操作。（技术角度看，vector 也可以在两端操作，但在头部操作效率很差，无法接受。）
deque 没有容量概念：它动态地以分段连续空间组合而成，可以随时增加一段新的空间并拼接起来，因而逻辑上仍然可以看作是连续空间。

#### 迭代器
提供 Random Access Iterator。但它的迭代器不是普通指针，而是复杂的实现方式（因此，除非必要，尽可能选用 vector。比如对 deque 排序操作，完全可以先将其复制到一个 vector，使用 STL sort 排序后再复制回 deque）。由于避开了 vector 扩充过程中“重新分配空间、复制、释放旧空间”的代价高昂的操作，其迭代器实现在维护“整体连续空间”的假象时只能以复杂架构作为代价。

###################### 基于容器的适配器
**适配器**
以既有容器作为底层结构，稍作修改，即可形成一个新的数据结构。这种依赖底层结构，通过修改底层结构接口完成自身所有工作的新的结构，称为 adapter（适配器）。因而 stack、queue 等并不被归类为容器，而是容器适配器（container adapter）。STL 提供以下几种。

### stack
一种 FIFO 的数据结构，只有一个开口：通过该开口新增/移除元素、取得最顶端元素，但不允许（没有办法）存取顶端元素之外的其他元素，即，不能遍历。这也意味着，**stack 没有迭代器**。

#### 实现
SGI STL stack 为例，默认以 deque 作为底层结构，实现很简单（复杂工作在 deque 的实现）。stack 使用到的 deque 底层函数有：empty、size、back、push_back、pop_back。list 也具备这些函数，并且也是双向开口的，因而也可以作为底层结构实现 stack。

### queue
也是一种 FIFO 的数据结构，有两个开口：从顶端获取元素，从底端加入元素，没有其他办法获取其他元素。所以类似于 stack，不允许遍历，也没有迭代器，同样是一个适配器结构。可以 deque、list 作为底层结构实现。

### heap
heap 并不属于 STL 容器组件，而是作为 priority queue 的助手。其实现是 binary heap（二叉堆），即，一种 complete binary tree（完全二叉树）。由于其元素遵循完全二叉树的排序规则，heap 不提供遍历功能，也就没有迭代器。

### priority_queue
优先队列。只允许在底端加入元素，在顶端取出元素。新增/移除元素后，依照权值重新排序。默认以 deque 作为底部容器，加上 heap 处理规则实现。

###################### 非标准容器
### slist
STL list 是双向链表。SGI STL 提供了一个单向链表：slist，不在标准之内。和 list 相同的是插入/删除不会导致全部迭代器失效（局部失效需要重建）；不同的是，它的迭代器属于单向的 Forward Iterator。因而功能上有许多限制，但好处是占用的空间更小，某些操作更快。基于效率（而非技术实现）考虑，slist 不提供 push_back()，只提供 push_front（），因此 slist 的元素次序和插入顺序相反。

