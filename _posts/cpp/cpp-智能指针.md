---
title: cpp-智能指针
date: 2018-05-22 16:20:41
categories: C++
tags: C++
---
[toc]
## 智能指针（Smart Pointer）
为了解决内存泄漏问题，C++11 引入了智能指针。智能指针实质上是一个对象，只是其行为表现像是一个指针。
其原理是，接受一个申请好的内存地址，构造一个保存在 **栈上** 的智能指针对象，当程序退出栈的作用域范围后，由于栈上的变量自动被销毁，智能指针内部保存的内存也就被释放掉了（除非将智能指针保存起来）。
C++11 提供了3种智能指针：std::shared_ptr、std::unique_ptr、std::weak_ptr，定义在<memory\>中。

### shared_ptr
使用引用计数，即可以有多个 shared_ptr 实例指向同一块动态分配的内存，每一个 shared_ptr 的拷贝都指向相同的内存。每使用一次，内部的引用计数 +1,每析构一次则 -1,当最后一个 shared_ptr 离开作用域，即引用计数为0时，释放该堆内存。shared_ptr 内部的引用计数是线程安全的，但对对象的读写需要加锁。

### unique_ptr
不同于 shared_ptr 的引用计数，unique_ptr 意味着所有权，其离开作用域时，会立即释放所指向的内存。它也是线程安全的。
unique_ptr 应该是默认的智能指针类型，只有需要共享资源时，才使用 shared_ptr。

### weak_ptr
严格来说它不是一个智能指针（也不是一个指针），因为它不能使用 operator* 和 operator->。它也不负责维护底层内存。唯一的作用是，检查底层被管理的内存是否还有效，即对象是否还存在，并在有效时可以提供一个指向内存的 shared_ptr 以供使用。
一般配合 shared_ptr 使用：可以指向 shared_ptr 所指向的对象，但不增加对象的引用计数。这就有可能出现 weak_ptr 所指向的对象实际上已经被释放的情况，因此 weak_ptr 有一个 lock()函数，它可以尝试取回一个指向对象的 shared_ptr。