---
title: 常见问题-cpp
date: 2018-05-23 10:23:39
categories: cpp
tags: [cpp, Q&A]
---
[toc]
# 内存

## segment fault
程序出现“段错误” or “非法操作，该内存地址不能 read/write”的错误，是典型的非法指针解引用造成的。当指针指向一个不允许访问（没有读写权限）的内存地址，而程序却试图利用指针读写该地址的时候，就会出现这个错误。
在 windows/linux 内存布局中，有些地址是始终不允许读写的，如 0 地址；一些地址一开始不允许读写，应用程序必须事先请求获取这些地址的读写权限；或者一些地址一开始并没有映射到实际的物理内存，应用程序必须事先请求将这些地址映射到实际的物理地址后才能自由访问。
造成该错误最普遍的原因有：
* 将指针初始化为 NULL，之后却没有给它一个合理的值就开始使用该指针；
* 没有初始化栈上的指针，而指针的值一般会是随机数，之后直接开始使用指针。
etc.

# 复合类型（compound type）
基于其他类型定义的类型，包括引用、指针等。

## 理解“声明语句”
一条声明语句由一个 **基本数据类型（base type）** 和紧随其后的一个 **声明符（declarator）列表** 组成。每个声明符命名了一个变量，并指定该变量为“与基本数据类型有关的某种类型”。

## 指针

### void*
含义是 **指向未知类型对象的指针**（i.e. 仍然是个指针）。在某些偏向底层的代码中，偶尔需要在不知道对象确切类型的情况下，仅通过对象在内存中的地址存储或传递对象，此时会用到 void*。
除了函数指针和指向类成员的指针，其他任意类型对象的指针都能被赋值给一个 void* 类型的变量（包括一个 void* 赋值给另一个 void*）。void* 也能比较是否相等（地址），还能把 void* 显式转换成其他类型。而，编译器事实上并不知道 void* 所指的对象到底是什么类型，所以对它执行其他操作可能不太安全并且会引发编译器错误。所以要想使用 void*，必须把它显式转换成某一特定类型的指针。


# 数据结构

## vector 容量变化
经测试发现，VS 环境下是1.5倍增长，而 Linux 下使用编译运行发现，是2倍率增长。可以用 reserve()函数指定初始容量。
增长包括重新分配内存空间、拷贝原空间、释放原空间三个过程，具体策略为当添加元素时，如果vector空间大小不足，则会以原大小的1.5倍另外配置一块较大的新空间，然后将原空间内容拷贝过来，在新空间的内容末尾添加元素，并释放原空间。也就是说vector的空间动态增加大小，并不是在原空间之后的相邻地址增加新空间，因为vector的空间是线性连续分配的，不能保证原空间之后有可供配置的空间。
* 空的vector对象，size()和capacity()都为0;
* 当空间大小不足时，新分配的空间大小为原空间大小的2倍;
* 使用reserve()预先分配一块内存后，在空间未满的情况下，不会引起重新分配，从而提升了效率;
* 当reserve()分配的空间比原空间小时，是不会引起重新分配的;
* resize()函数只改变容器的元素数目，未改变容器大小。

# 重载
## 不能重载的操作符有：
* .（点号）  成员选择
* .*  通过指向成员的指针访问成员
* ::（域解析符）  
* ?:（条件语句运算符）  
* sizeof（求字节运算符）
* alignof()  对象的对齐方式
* typeid，static_cast，dynamic_cast，interpret_cast（类型转换符）

# O
## POD
Plain Old Data。指 C 风格的 struct 结构体定义的数据结构，其中 struct 结构体中只能定义常规数据类型，不能含有自定义数据类型。