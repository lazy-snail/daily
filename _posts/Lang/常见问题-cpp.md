---
title: 常见问题-cpp
date: 2018-05-23 10:23:39
categories: [C++]
tags: [C++, Q&A]
---
[toc]
## 内存

### segment fault
程序出现“段错误” / “非法操作，该内存地址不能 read/write”的错误，是典型的非法指针解引用造成的。当指针指向一个不允许访问（没有读写权限）的内存地址，而程序却试图利用指针读写该地址的时候，就会出现这个错误。
在 windows/linux 内存布局中，有些地址是始终不允许读写的，如 0 地址；一些地址一开始不允许读写，应用程序必须事先请求获取这些地址的读写权限；或者一些地址一开始并没有映射到实际的物理内存，应用程序必须事先请求将这些地址映射到实际的物理地址后才能自由访问。
造成该错误最普遍的原因有：
* 将指针初始化为 NULL，之后却没有给它一个合理的值就开始使用该指针；
* 没有初始化栈上的指针，而指针的值一般会是随机数，之后直接开始使用指针。
etc.


## 复合类型（compound type）
基于其他类型定义的类型，包括引用、指针等。

### 理解“声明语句”
一条声明语句由一个 **基本数据类型（base type）** 和紧随其后的一个 **声明符（declarator）列表** 组成。每个声明符命名了一个变量，并指定该变量为“与基本数据类型有关的某种类型”。

### 指针

#### void*
含义是 **指向未知类型对象的指针**（i.e. 仍然是个指针）。在某些偏向底层的代码中，偶尔需要在不知道对象确切类型的情况下，仅通过对象在内存中的地址存储或传递对象，此时会用到 void*。
除了函数指针和指向类成员的指针，其他任意类型对象的指针都能被赋值给一个 void* 类型的变量（包括一个 void* 赋值给另一个 void*）。void* 也能比较是否相等（地址），还能把 void* 显式转换成其他类型。而，编译器事实上并不知道 void* 所指的对象到底是什么类型，所以对它执行其他操作可能不太安全并且会引发编译器错误。所以要想使用 void*，必须把它显式转换成某一特定类型的指针。



## O

### POD
Plain Old Data。指 C 风格的 struct 结构体定义的数据结构，其中 struct 结构体中只能定义常规数据类型，不能含有自定义数据类型。