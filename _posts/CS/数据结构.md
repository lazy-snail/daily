---
title: 数据结构
date: 2018-06-20 08:52:59
categories: CS
tags: [CS, Q&A]
---
[toc]
# Tree
## 几种树结构优缺点比较
### BST
BST 的性能取决于其平衡情况，当出现极端的不平衡时，查找性能会回落到线性。
**时间复杂度**
* 查找：树高为 logN 时，为 O(logN)，随着树不平衡加剧，恶化到线性；
* 插入：与查找一个不存在的数据代价相同；
* 删除：定位+考虑删除情况，不超过当前树形态下查找时间复杂度。

### AVL 树
严格平衡二叉搜索树，就是为了解决 BST 在最坏情况下查找性能为线性的情况，通过旋转保持自平衡。适用于 **查询多，增删少** 的情况。
**时间复杂度**
* 查找：O(logN)；
* 插入：每一次插入数据使得某些结点的平衡因子超过 1，要进行旋转操作，总体上代价在 O(logN) 级别；
* 删除：删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。每一次删除操作最多需要 O(logN) 次旋转。因此，删除操作的时间复杂度为 O(logN) + O(logN) = O(2logN)。

### RBT
非严格平衡，最长路径长度不超过最短路径长度的 2 倍，只要求部分地达到平衡，减少了旋转次数（任何不平衡都会在三次旋转之内解决），从而提高了性能。
**时间复杂度**
* 查找：最好情况下为 O(logN)，最坏情况下比 AVL 要差一些，但也远远好于 BST；
* 插入：旋转+变色，基本上为 2 次旋转+O(logN)变色，还是在 O(logN) 级别；
* 删除：最多只需要 3 次旋转操作。

### B-Tree（平衡多路查找树）
**WHY**
即 B 树，这里的 B 是平衡的意思。当数据量维持在内存查找的量级时，RBT 无疑已经是很好的选择（实际上很多实现还有进一步优化），但数据量突破内存极限，不得不进行磁盘查找情况下，比如 OS 文件目录存储，数据库中的文件索引结构的存储，这些情况不可能在内存中建立查找结构，必须在磁盘中建好这样的结构。这种情况下，RBT 并不是一个好的选择：因为在磁盘中组织查找结构，那么从任何一个节点指向其他节点都可能需要执行一次磁盘读取数据到内存再比较的操作，而磁盘 I/O 操作，相比于内存操作效率是相当低下的，这就导致 RBT 效率很不稳定。所以需要新的数据结构来适应这种场景，而 B-Tree 就是这一背景下的产物。
B 树中的每个结点根据实际情况可以包含大量的关键字信息和分支(当然是不能超过磁盘块的大小，根据磁盘驱动(disk drives)的不同，一般块的大小在1k~4k左右)；这样树的深度降低了，这就意味着查找一个元素只要很少结点从外存磁盘中读入内存，很快访问到要查找的数据。意即，通过降低树的高度，来减少磁盘操作，从而提高性能。

**时间复杂度**
* 查找： 作为一个平衡多路查找树 (m-叉)，查找分成两种：一种是从一个结点查找另一结点的地址的时候，需要定位磁盘地址(查找地址)，查找代价极高。另一种是将结点中的有序关键字序列放入内存，进行优化查找(可以用折半)，相比查找代价极低。而B树的高度很小，因此在这一背景下，B树比任何二叉结构查找树的效率都要高很多。
* 插入： 插入会发生结点的分裂操作。当插入操作引起了 s 个节点的分裂时，磁盘访问的次数为 h(读取搜索路径上的节点)＋2s(回写两个分裂出的新节点)＋1（回写新的根节点或插入后没有导致分裂的节点）。因此，所需要的磁盘访问次数是 h+2s+1，最多可达到 3h+1。因此插入的代价是很大的。
* 删除：删除会发生结点合并操作。最坏情况下磁盘访问次数是 3h＝（找到包含被删除元素需要h次读访问）+（获取第 2 至 h 层的最相邻兄弟需要 h-1 次读访问）+（在第 3 至 h 层的合并需要 h-2 次写访问）+（对修改过的根节点和第 2 层的两个节点进行 3 次写访问）。

#### B+-Tree
B 树的一种变种，应文件系统所需而产生。
一棵 m 阶的 B+ 树和 m 阶的 B 树的差异在于：
* 有 n 棵子树的结点中含有 n 个关键字； (而B 树是 n 棵子树有 n-1个 关键字)
* 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而 B 树的叶子节点并没有包括全部需要查找的信息)
* 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而 B 树的非终节点也包含需要查找的有效信息)。

#### B*-Tree
B+ 树的变体，在 B+ 树非根和非叶子结点再增加指向兄弟的指针；B* 树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为 2/3（代替 B+ 树的 1/2）。
B* 树分配新结点的概率比 B+ 树要低，空间使用率更高。

**对比**
B 树：有序数组+平衡多叉树；数据存在于非叶子节点上
B+ 树：有序数组链表+平衡多叉树；数据只存在于叶子上。
B* 树：一棵丰满的 B+ 树。


[参考]
https://blog.csdn.net/u010025211/article/details/47979209
https://blog.csdn.net/wl044090432/article/details/54585765
https://blog.csdn.net/sup_heaven/article/details/39313731
http://kongchen.github.io/why-b-tree/
https://blog.csdn.net/v_JULY_v/article/details/6530142