---
title: java-线程
date: 2018-04-14 15:39:53
categories: java
tags: [java, 并发, 线程]
---
[toc]
## CPU 调度单位
大多数现代 OS 中，都是以线程为基本的调度单位，而不是进程。
在并发编程中，需要处理两个关键问题：**线程之间的通信和同步**。线程间通信主要通过 **共享内存和消息传递** 两种方式，而 java 的并发采用的是共享内存模型，线程间的通信是隐式进行的，对程序员透明。在共享内存并发模型里，同步是显式进行的，即必须显式指定某个方法/代码段需要在线程之间互斥执行；而在消息传递并发模型里，由于消息的发送必须在消息的接受之前，因此同步是隐式进行的。
线程允许在同一个进程中同时存在多个程序控制流。共享进程范围内的一些资源：堆资源、内存句柄、文件句柄等；但线程拥有自己的程序计数器（PC）、栈、局部变量等。

## 两级调度模型
HotSpot 采用 **一对一映射模型**，即每一个 java 线程都唯一映射到一条本地操作系统内核线程。在上层，进程使用用户级的调度器（Executor 框架）将任务映射到线程；在底层，OS 内核将这些线程映射到硬件处理器（CPU 核）上：
{% asset_img 任务两级调度模型.PNG 任务两级调度模型}

## java 线程
多线程线程是 java 程序执行的基本模型，也被成为轻量级进程。所有 java 程序至少由一个控制线程组成——即使一个只有 main( ) 函数的程序也是在 JVM 中作为一个线程运行的。java 语言设计中的创新之一就是：直接把跨平台的线程模型和正规的内存模型集成到语言中。

## 创建方式
java 中创建线程的方式主要有 3 种：

### 继承 Thread
继承 Thread 类来创建线程类，需要重写 Thread 类的 run()，该方法就代表了线程所要完成的任务。

### Runnable 接口
扩展 Runnable 接口，实现该接口的 run()，该方法同样代表线程所要完成的任务。调用 start() 来启动线程。

### Callable Future
* 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。
* 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。
* 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。
* 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。

### vs


## 停止方法
* 使用退出标志，即当 run() 方法完成后线程终止，属于正常退出；
* 使用 interrupt() 方法，中断线程；
* _stop()、suspend()、resume()都是作废的方法，会产生不可预料的结果，不建议使用。_

## 线程安全的两个方面
线程安全包含 **原子性** 和 **可见性** 两个方面，java的同步机制都是围绕这两个方面来确保线程安全的。
可见性在内存模型中遇到的同步问题有：
* 在编译器中生成的指令顺序，可能与源代码中的顺序不同；
* 编译器会把变量保存到寄存器而不是内存中；
* 处理器可以采用乱序/并行等方式来执行指令；
* 缓存可能会改变将写入变量提交到主内存的次序；
* 保存在处理器本地缓存中的值，对于其他处理器是不可见的；
etc.

这些因素会使得一个线程无法看到变量的最新值，并且会导致其他线程中的内存操作似乎在乱序执行——如果没有使用正确的同步。

## 状态