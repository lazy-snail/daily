---
title: Java-线程安全实现
date: 2018-04-14 15:39:53
categories: java
tags: [java, 并发]
---
[toc]
线程安全的实现方式。

# 线程安全
在 JVM 中，每个对象和类在逻辑上都是和一个监视器相关联的。对于对象来说，相关联的监视器保护对象的实例变量。对于类来说，监视器保护类的类变量。（如果一个对象没有实例变量，或者一个类没有变量，相关联的监视器就什么也不监视）。
为了实现监视器的排他性监视能力，JVM 为每一个对象和类都关联一个锁。代表任何时候只允许一个线程拥有的特权。线程访问实例变量或者类变量不需锁。但是如果线程获取了锁，那么在它释放这个锁之前，就没有其他线程可以获取同样数据的锁了。（锁住一个对象就是获取对象相关联的监视器）。类锁实际上用对象锁来实现。当虚拟机装载一个 class 文件的时候，它就会创建一个 java.lang.Class 类的实例。当锁住一个对象的时候，实际上锁住的是那个类的 Class 对象。
一个线程可以多次对同一个对象上锁。对于每一个对象，JVM 维护一个加锁计数器，线程每获得一次该对象，计数器就加1，每释放一次，计数器就减 1，当计数器值为0时，锁就被完全释放了。
java 编程人员不需要自己动手加锁，对象锁是 JVM 内部使用的。在 java 程序中，只需要使用 synchronized 块或者 synchronized 方法就可以标志一个监视区域。当每次进入一个监视区域时，JVM 都会自动锁上对象或者类。

# 隐式锁 synchronized
[java-Synchronized]()

# 显式锁 Lock 和 ReentrantLock 
加锁和解锁都是显式实现的。

# volatile
见 _java 内存模型_

### 锁与无锁

#### 基于锁的并发
优点：
1、编程模型简单，如果小心控制上锁顺序，一般来说不会有死锁的问题；
2、可以通过调节锁的粒度来调节性能。
缺点：
1、所有基于锁的算法都有死锁的可能；
2、上锁和解锁时进程要从用户态切换到内核态，并可能伴随有线程的调度、上下文切换等，开销比较重；
3、对共享数据的读与写之间会有互斥。

#### 无锁编程（lock free）
常见的lock free编程一般是基于CAS(Compare And Swap)操作：CAS(void *ptr, Any oldValue, Any newValue);
即查看内存地址ptr处的值，如果为oldValue则将其改为newValue，并返回true，否则返回false。X86平台上的CAS操作一般是通过CPU的CMPXCHG指令来完成的。CPU在执行此指令时会首先锁住CPU总线，禁止其它核心对内存的访问，然后再查看或修改*ptr的值。简单的说CAS利用了CPU的硬件锁来实现对共享资源的串行使用。
优点：
1、开销较小：不需要进入内核，不需要切换线程；
2、没有死锁：总线锁最长持续为一次read+write的时间；
3、只有写操作需要使用CAS，读操作与串行代码完全相同，可实现读写不互斥。
缺点：
1、编程非常复杂，两行代码之间可能发生任何事，很多常识性的假设都不成立。
2、CAS模型覆盖的情况非常少，无法用CAS实现原子的复数操作。

#### 对比
在性能层面上，CAS与mutex/readwrite lock各有千秋，简述如下：
1、单线程下CAS的开销大约为10次加法操作，mutex的上锁+解锁大约为20次加法操作，而readwrite lock的开销则更大一些。
2、CAS的性能为固定值，而mutex则可以通过改变临界区的大小来调节性能；
3、如果临界区中真正的修改操作只占一小部分，那么用CAS可以获得更大的并发度。
4、多核CPU中线程调度成本较高，此时更适合用CAS。
跳表和红黑树的性能相当，最主要的优势就是当调整(插入或删除)时，红黑树需要使用旋转来维护平衡性，这个操作需要动多个节点，在并发时候很难控制。而跳表插入或删除时只需定位后插入，插入时只需添加插入的那个节点及其多个层的复制，以及定位和插入的原子性维护。所以它更加可以利用CAS操作来进行无锁编程。