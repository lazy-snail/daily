---
title: java-synchronized
date: 2018-05-26 14:19:58
categories: java
tags: [java, 并发]
---
[toc]
线程安全的实现方式之一。

# 隐式锁
synchronized 采用的是 CPU 悲观锁机制，即线程获得的是独占锁，是一种隐式锁实现：隐式地声明一个锁，所有线程必须获得该锁，才能进入该锁保护的代码段进行操作，**只有在对象锁是共享且唯一时才会起到同步作用**。
一方面，该关键字实现原子性或者确定“临界区”，另一方面，保证状态修改的“内存可见性”。
**synchronized 关键字默认是不被继承的，即子类并不会继承父类的这种方式的同步声明**。

# 作用对象
java 中每个对象都可以作为同步对象，Object 类中有 wait() 和 notify() 方法，它们必须用在被 synchronized 同步的 Object 的临界区内。通过 wait() 可以使得处于临界区内的线程进入阻塞状态，同时释放被同步对象的控制权，而 notify() 可以唤醒一个因调用了 wait() 而处于阻塞状态中的线程，使其进入就绪状态。被重新换醒的线程会试图重新获得临界区的控制权，并继续执行临界区内 wait() 之后面的代码。如果发出 notify() 时没有处于阻塞状态中的线程,那么该信号会被忽略。
* 对于普通同步方法，锁是当前实例对象；
* 对于静态同步方法，锁是当前类的 Class 对象；
* 对于同步方法块，锁是 Synchronized 括号中配置的对象。

# 使用方式
当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。有两种使用方式：
* 同步方法：
```java
// 如下形式，获取 this 对象的内置锁：
// public synchronized methodName (参数){临界区}
public synchronized void myMethod(){
    try {
        // todo sth.
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```
* 同步语句块:
```java
// 如下形式，获取“对象名”对象的内置锁：
// synchronized (对象名){临界区}
public void myMethod(){
    try {
        // todo sth.
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    synchronized (object) {
        // todo sth.
    }
}
```
## 作用效果
* 当一个线程正在访问一个对象的 synchronized 方法，那么其他线程不能访问该对象的所有 synchronized 方法：一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的 synchronized 方法；
* 当一个线程正在访问一个对象的 synchronized 方法，那么其他线程能访问该对象的非 synchronized 方法：也很好理解，访问非 synchronized 方法不需要获得该对象的锁，假如一个方法没用 synchronized 关键字修饰，说明它不会使用到临界资源，即不存在线程安全性问题，那么其他线程是可以访问这个方法的。

## 二者区别
首先要明确的是：无论 synchronized 加在方法上还是语句块上，它取得的都是对象的内置锁，即锁住的都是对象，而不是把一个方法或者一段代码当做锁。
其次如上描述，同步方法是对当前对象进行加锁（获取其内置锁），而同步语句块是对某一个对象（synchronized (对象)）进行加锁。使用同步方法在某些情况下是有弊端的：如果一个线程调用该方法执行一个长时间任务，那么其他线程要想调用这个方法就必须等待较长时间，此时可以考虑将同步缩小范围，放在方法中的具体语句块中。
此外，同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用同步语句块锁定关键代码即可。 
更具体的解释：
synchronized 同步方法：
* 对其他 synchronized 同步方法或 synchronized(this)同步代码块调用呈阻塞状态；
* 同一时间只有一个线程可以执行 synchronized 同步方法中的代码；
synchronized(this) 同步代码块
* 对其他 synchronized 同步方法或 synchronized(this)同步代码块调用呈阻塞状态；
* 同一时间只有一个线程可以执行 synchronized(this)同步代码块中的代码；
synchronized(非 this 对象 x)
* 在多个线程持有"对象监视器"为同一对象的前提下，同一时间只有一个线程可以执行 synchronized(非 this 对象 x)同步代码块中的代码；
* 当持有"对象监视器"为同一对象的前提下，同一时间只有一个线程可以执行 synchronized(非 this 对象 x)同步代码块中的代码。
可以理解为，当不同的对象 x 被传入到同步语句块时，线程可以同步进行而不会相互干扰。

## 类锁 对象锁
修饰非静态方法时，实际上是对调用该方法的对象加锁，即“对象锁”；而修饰静态方法时，实际上时对该类对象加锁，即“类锁”，所有调用静态方法的对象都会呈现出同步的效果。以下情况：
* 用类直接在两个线程中调用两个不同的同步方法（即静态方法）：会产生互斥，因为对静态对象加锁实际上是对类（.class）加锁，类对象只有一个，可以理解为任何时候都只有一个空间，里面有 N 房间，只有空间上的一把锁，因此房间（同步方法）之间是互斥的。
* 用一个类的静态对象在两个线程中调用静态方法和/或非静态方法：会产生互斥，因为是同一个对象上的调用。
* 一个对象在两个线程上分别调用一个静态同步方法和一个非静态同步方法：不会产生互斥，因为两个方法的锁类型不同，一个是对象锁，一个是类锁，可以并发执行。

获取类锁方法之一是使用类似同步语句块的声明，区别是参数：
```java
public void myMethod(){
    try {
        // todo sth.
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    // 这里参数不是某对象，而是类对象
    synchronized (className.class) {
        // todo sth.
    }
}
```
线程在获取类锁之后，仍然可以获取该类的实例对象的锁（对象锁），因为二者并不是“同一个锁”。


# 优化
从 JDK1.6 开始，synchronized 可以有很多优化：有适应自旋、锁粗化、锁消除、偏向锁、轻量级锁等，以减少获得/释放锁带来的性能消耗，性能上有很大提升。所以目前共有 4 种锁状态，级别从低到高：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。这几个状态会随着竞争情况的加剧而逐渐升级，但不可以降级：目的是为了提高获得锁和释放锁的效率。

## 适应性自旋（Adaptive Spinning）/自旋锁
从轻量级锁获取的流程可见，当线程在获取轻量级锁的过程中执行 CAS 操作失败时，是要通过自旋来获取重量级锁的。但是，自旋是需要消耗 CPU 的，如果一直获取不到锁的话，那该线程就一直处于自旋状态。解决这个问题最简单的方法就是指定自旋的次数，比如循环10次，如果还没有获取到锁就进入阻塞状态。JDK 采用的方法是“适应性自旋”：如果线程成功自旋（获得锁），则下次自旋的次数会更多，如果失败，自旋的次数会减少。

## 锁粗化（Lock Coarsening）
将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。
```java
public class StringBufferTest {
    StringBuffer stringBuffer = new StringBuffer();
    public void append(){
        stringBuffer.append("a");
        stringBuffer.append("b");
        stringBuffer.append("c");
    }
}
```
如果这里每次调用 stringBuffer.append 方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次 append 方法时进行加锁，最后一次 append 方法结束后进行解锁。

## 锁消除（Lock Elimination）
删除不必要的加锁操作。根据代码逃逸技术，如果 jvm 判断出一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，也就无需加锁。


## 偏向锁
偏向锁的引入是为了在没有多线程竞争的情况下尽量减少不必要的轻量级锁执行，因为轻量级锁的获取/释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令。
可见，轻量级锁是 **在线程交替执行同步块时提高性能**，偏向锁是 **在只有一个线程执行同步块时进一步提高性能**。

### 偏向锁获取过程
1. 访问 Mark Word 中偏向锁的标识是否设置成1，锁标志位是否为 01——确认为可偏向状态；
2. 如果为可偏向状态，则测试线程 ID 是否指向当前线程：如果是，进入步骤（5），否则进入步骤（3）；
3. 如果线程 ID 并未指向当前线程，则通过 CAS 操作竞争锁。如果竞争成功，则将 Mark Word 中线程 ID 设置为当前线程 ID，然后执行（5）；如果竞争失败，执行（4）；
4. 如果 CAS 获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码；
5. 行同步代码。

### 偏向锁释放过程
偏向锁只有遇到其他线程尝试竞争偏向锁时（上述获取过程的第4步），持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。

## 轻级量锁
“轻量”是相对于使用 OS 互斥量来实现的传统锁而言的，**它并非用来代替重量级锁，而是在没有多线程竞争的前提下，减少传统的重量级锁的使用产生的性能消耗**。使用场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量锁升级为重量级锁。

### 轻量级锁加锁过程
1. 代码进入同步块时，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），jvm 首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝，官方称之为 Displaced Mark Word；
2. 拷贝对象头中的 Mark Word 复制到锁记录中；
3. jvm 将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock record 里的owner 指针指向 object mark word。如果更新成功，则执行步骤（3），否则执行步骤（4）；
4. 更新操作成功，这个线程拥有该对象的锁，并且对象 Mark Word 的锁标志位设置为“00”，即此对象处于轻量级锁定状态；
5. 更新操作失败，jvm 首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁升级为重量级锁，锁标志的状态值变为“10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。

### 轻量级锁释放过程
1. 通过 CAS 操作尝试把线程中复制的 Displaced Mark Word 对象替换当前的Mark Word；
2. 如果替换成功，整个同步过程完成；
3. 如果替换失败，说明有其他线程尝试过获取该锁（此时锁已升级），需要在释放锁的同时，唤醒被挂起的线程。

## 锁转换
重量级锁、轻量级锁和偏向锁之间的转换
{% asset_img Synchronized锁转换.png Synchronized锁转换 %}

# 关于 java 对象头
Synchronized 使用的锁存放在 java 对象头里。如果对象是数组类型，jvm 用3个字宽（即3个word，在32位 jvm 中1字宽等于4字节，即32位）存储对象头，非数组对象使用2字宽存储对象头：
{% asset_img java对象头.png java对象头 %}

其中 mark word 的状态随着锁标志位的变化如下（默认为无锁状态）：
{% asset_img Synchronized锁状态.png Synchronized锁状态 %}









https://blog.csdn.net/lcc793385991/article/details/57551827
https://blog.csdn.net/u010842515/article/details/65443084
https://blog.csdn.net/zwan0518/article/details/8725704