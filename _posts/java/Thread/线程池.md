---
title: 线程池
date: 2018-06-08 19:11:50
categories: java
tags: [java, 并发, 线程]
---
[toc]
# 线程池
线程能够很好地提升进程执行速度和提高资源利用。而仅仅在需要一个线程的时候才去创建的话，在某些情况下就会带来问题：如果并发的线程数量众多，并且每个线程都是执行很短的时间就结束了，这种场景下，频繁创建/销毁线程就会浪费很多时间，在很大程度上降低系统效率。
此时，一个可行的方案就是，能否对线程进行复用——执行完一个任务后，委派其他任务给它继续执行，而不是将其销毁。java 中称之为线程池技术。

## 为什么线程池可以提升性能？
上面提到了频繁创建/销毁线程会降低性能。具体而言，new Thread 的弊端有：
* 每次 new Thread 新建对象性能差；
* 线程缺乏统一管理，可能无限制创建新线程，相互之间竞争，以及可能占用过多系统资源导致 OOM（每个线程需要大约 1MB 内存）；
* 缺乏更多功能，如定时执行、定期执行、线程中断等。

而相对的，线程池的好处有：
* 复用已存在的线程，减少线程对象的创建、销毁的开销；
* 可有效控制最大并发线程数量，提高系统资源的使用率，同时避免过多资源竞争，导致阻塞；
* 提供定时执行、定期执行、单线程、并发数控制等。

# 4 种方式创建线程池
通过 Executors 提供的 4 个静态工厂方法创建不同类型的线程池。

## newCachedThreadPool
创建一个可缓存线程池，如果线程池长度超过处理需求，可灵活回收空闲线程，若没有可回收，则为任务新建线程。此种线程池（理论上）可无限扩张，然而当执行下一个任务时如果探测到前一个任务已经完成，那么就会复用（而非新建）线程。

## newFixedThreadPool
创建一个固定长度的线程池。也就是可根据系统资源情况，控制线程的最大并发数，超出的线程会在队列种等待。

## newScheduledThreadPool
创建一个固定长度的线程池。支持定时/延迟和周期执行任务等功能。

## newSingleThreadExecutor
创建一个单线程化的线程池，即它只会使用一个线程来执行所有任务（相当于串行操作），保证所有任务按照指定顺序（FIFO、LIFO、优先级等）顺序执行。

# Executor 框架接口
以上创建线程池的方式，从源码可见，都是调用 ThreadPoolExecutor 类实现的，而该类属于 JUC 中Executor 框架接口的具体实现。结构关系：
{% asset_img 线程池类结构关系.png 线程池相关类结构关系 %}

## 从 Executor 接口开始
```java
public interface Executor {
    void execute(Runnable command);
}
```
Executor 接口只有一个 execute 方法，用来替代通常创建或启动线程的方法，如，使用 Thread 来创建并启动线程：
```java
Thread t = new Thread();
t.start();
```
而使用 Executor 来启动线程执行任务的代码如下：
```java
Thread t = new Thread();
executor.execute(t);
```
对于不同的 Executor 实现，execute() 方法可能是创建一个新线程并立即启动，也有可能是使用已有的工作线程来运行传入的任务，也可能是根据设置线程池的容量或者阻塞队列的容量来决定是否要将传入的线程放入阻塞队列中或者拒绝接收传入的线程。

## ExecutorService 接口
继承了 Executor 接口，提供了管理终止的方法，以及可以为跟踪一个或多个异步任务执行状况而生成 Future 的方法，增加了 shutDown()、shutDownNow()、invokeAll()、invokeAny()、submit() 等方法。如果需要支持即时关闭，即 shutDownNow() 方法，则任务需要正确处理中断。

## ScheduledExecutorService 接口
继承了 ExecutorService 接口并增加了 schedule 方法。调用 schedule 方法可以在指定的延时后执行一个 Runnable 或者 Callable 任务。ScheduledExecutorService 接口还定义了按照指定时间间隔定期执行任务的 scheduleAtFixedRate() 方法和 scheduleWithFixedDelay() 方法。

# ThreadPoolExecutor 类
继承自 AbstractExecutorService 虚类，后者实现了 ExecutorService 接口。

## 重要字段
```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3;
private static final int COUNT_MASK = (1 << COUNT_BITS) - 1;

// runState is stored in the high-order bits
private static final int RUNNING    = -1 << COUNT_BITS;
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;
```
ctl 是对线程池的运行状态和线程池中有效线程数量进行控制的一个字段：包含两部分信息：
* 线程池的运行状态（runState）；
* 线程池内有效线程的数量（workerCount）。
可见，使用 int 的高 3 位保存 runState，低 29 位保存 workerCount：COUNT_BITS = 29。COUNT_MASK 用来计算最大线程数，位 2^29-1，约 5 亿。

## 构造方法
```java
public ThreadPoolExecutor(
    int corePoolSize,
    int maximumPoolSize,
    long keepAliveTime,
    TimeUnit unit,
    BlockingQueue<Runnable> workQueue,
    ThreadFactory threadFactory,
    RejectedExecutionHandler handler) 
    {}
```
方法参数字段解释：
* corePoolSize：核心线程数量，当有新任务在 execute() 方法提交时，会执行以下判断：
> 如果运行的线程少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；
> 如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当 workQueue 满时才创建新的线程去处理任务；
> 如果设置的 corePoolSize 和 maximumPoolSize 相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若 workQueue 未满，则将请求放入 workQueue 中，等待有空闲的线程去从 workQueue 中取任务并处理；
> 如果运行的线程数量大于等于 maximumPoolSize，这时如果 workQueue 已经满了，则通过 handler 所指定的策略来处理任务；
> 所以，任务提交时，判断的顺序为 corePoolSize --> workQueue --> maximumPoolSize。
* maximumPoolSize：最大线程数量；
* workQueue：保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:
> 直接切换：这种方式常用的队列是 SynchronousQueue，但现在还没有研究过该队列，这里暂时还没法介绍；
> 使用无界队列：一般使用基于链表的阻塞队列 LinkedBlockingQueue。如果使用这种方式，那么线程池中能够创建的最大线程数就是 corePoolSize，而maximumPoolSize 就不会起作用了（后面也会说到）。当线程池中所有的核心线程都是 RUNNING 状态时，这时一个新的任务提交就会放入等待队列中;
> 使用有界队列：一般使用 ArrayBlockingQueue。使用该方式可以将线程池的最大线程数量限制为 maximumPoolSize，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。

* keepAliveTime：线程池维护线程所允许的空闲时间。当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；
* threadFactory：ThreadFactory 类型的变量，用来创建新线程。默认使用 Executors.defaultThreadFactory() 来创建线程。使用默认的 ThreadFactory 来创建线程时，会使新创建的线程具有相同的 NORM_PRIORITY 优先级并且是非守护线程，同时也设置了线程的名称;
* handler：RejectedExecutionHandler 类型的变量，表示线程池的饱和策略，及达到 maximumPoolSize。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：
> AbortPolicy：直接抛出异常，这是默认策略；
> CallerRunsPolicy：用调用者所在的线程来执行任务；
> DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；
> DiscardPolicy：直接丢弃任务；

## 线程池中线程初始化
默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。
在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：
* prestartCoreThread()：初始化一个核心线程；
* prestartAllCoreThreads()：初始化所有核心线程。

## 线程池状态
共有 5 种状态：
* RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务；
* SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown() 方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用 shutdown() 方法进入该状态）；
* STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；
* TIDYING：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。
* TERMINATED：在 terminated() 方法执行完后进入该状态，默认 terminated() 方法中什么也没有做。
　　进入 TERMINATED 的条件如下：
　　线程池不是 RUNNING 状态；
　　线程池状态不是 TIDYING 状态或 TERMINATED 状态；
　　如果线程池状态是 SHUTDOWN 并且 workerQueue 为空；
　　workerCount 为 0；
　　设置 TIDYING 状态成功。
{% asset_img 线程池状态转换.webp 线程池状态转换 %}

## 线程池大小配置
具体的设置需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。一般需要根据任务的类型来配置线程池大小：
* CPU 密集型任务，就需要尽量压榨 CPU，参考值可以设为 CPUs + 1；
* IO 密集型任务，参考值可以设置为 2 * CPUs


https://www.cnblogs.com/dolphin0520/p/3932921.html
https://juejin.im/entry/58fada5d570c350058d3aaad
https://blog.csdn.net/u011974987/article/details/51027795