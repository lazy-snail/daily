---
title: 线程池
date: 2018-06-08 19:11:50
categories: java
tags: [java, 并发, 线程]
---
[toc]
# 线程池
线程能够很好地提升进程执行速度和提高资源利用。而仅仅在需要一个线程的时候才去创建的话，在某些情况下就会带来问题：如果并发的线程数量众多，并且每个线程都是执行很短的时间就结束了，这种场景下，频繁创建/销毁线程就会浪费很多时间，在很大程度上降低系统效率。
此时，一个可行的方案就是，能否对线程进行复用——执行完一个任务后，委派其他任务给它继续执行，而不是将其销毁，即，将 Runnable 对象交给线程池，线程池负责委派一个线程执行调用对象的 run 方法，当 run 方法退出后，线程并不随之终结，而是返回线程池，由线程池管理。java 中称之为线程池技术。

## 为什么线程池可以提升性能？
上面提到了频繁创建/销毁线程会降低性能。具体而言，new Thread 的弊端有：
* 每次 new Thread 新建对象性能差；
* 线程缺乏统一管理，可能无限制创建新线程，相互之间竞争，以及可能占用过多系统资源导致 OOM（每个线程需要大约 1MB 内存）；
* 缺乏更多功能，如定时执行、定期执行、线程中断等。

而相对的，线程池的好处有：
* 复用已存在的线程，减少线程对象的创建、销毁的开销；
* 可有效控制最大并发线程数量，提高系统资源的使用率，同时避免过多资源竞争，导致阻塞；
* 提供定时执行、定期执行、单线程、并发数控制等。


## 线程池中线程初始化
默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。
在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：
* prestartCoreThread()：初始化一个核心线程；
* prestartAllCoreThreads()：初始化所有核心线程。

## 线程池状态
共有 5 种状态：
* RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务；
* SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown() 方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用 shutdown() 方法进入该状态）；
* STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；
* TIDYING：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。
* TERMINATED：在 terminated() 方法执行完后进入该状态，默认 terminated() 方法中什么也没有做。
　　进入 TERMINATED 的条件如下：
　　线程池不是 RUNNING 状态；
　　线程池状态不是 TIDYING 状态或 TERMINATED 状态；
　　如果线程池状态是 SHUTDOWN 并且 workerQueue 为空；
　　workerCount 为 0；
　　设置 TIDYING 状态成功。
{% asset_img 线程池状态转换.webp 线程池状态转换 %}

## 线程池大小配置
具体的设置需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。一般需要根据任务的类型来配置线程池大小：
* CPU 密集型任务，就需要尽量压榨 CPU，参考值可以设为 CPUs + 1；
* IO 密集型任务，参考值可以设置为 2 * CPUs

