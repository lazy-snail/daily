---
title: Java-线程安全实现
date: 2018-04-14 15:39:53
categories: java
tags: [java, 并发, 线程]
---
[toc]

# 线程安全
造成线程不安全的原因是多个线程对临界区资源的冲突访问（多线程只读是没有问题的，而一旦涉及到写，那么读写都将变得不可预知）。所以，从这个角度讲，保证线程安全的措施有：
* 同步/锁；
* 消除对变量的共享（ThreadLocal）。

## JVM 机制
在 JVM 中，每个对象和类在逻辑上都是和一个监视器相关联的。对于对象来说，相关联的监视器保护对象的实例变量。对于类来说，监视器保护类的类变量。（如果一个对象没有实例变量，或者一个类没有变量，相关联的监视器就什么也不监视）。
为了实现监视器的排他性监视能力，JVM 为每一个对象和类都关联一个锁。代表任何时候只允许一个线程拥有的特权。线程访问实例变量或者类变量不需锁。但是如果线程获取了锁，那么在它释放这个锁之前，就没有其他线程可以获取同样数据的锁了。（锁住一个对象就是获取对象相关联的监视器）。类锁实际上用对象锁来实现。当虚拟机装载一个 class 文件的时候，它就会创建一个 java.lang.Class 类的实例。当锁住一个对象的时候，实际上锁住的是那个类的 Class 对象。
一个线程可以多次对同一个对象上锁。对于每一个对象，JVM 维护一个加锁计数器，线程每获得一次该对象，计数器就加1，每释放一次，计数器就减 1，当计数器值为0时，锁就被完全释放了。
java 编程人员不需要自己动手加锁，对象锁是 JVM 内部使用的。在 java 程序中，只需要使用 synchronized 块或者 synchronized 方法就可以标志一个监视区域。当每次进入一个监视区域时，JVM 都会自动锁上对象或者类。

线程安全的实现方式有以下几种：
* 不使用单例模式，而是使用多实例；
* 使用锁机制：synchronized、lock 等；
* 使用 JUC 类库。

# 无同步方案
要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，笔者简单地介绍其中的两类。
**可重入代码（Reentrant Code）**：这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。相对线程安全来说，可重入性是更基本的特性，它可以保证线程安全，即所有的可重入的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。
可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。我们可以通过一个简单的原则来判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。
**线程本地存储（Thread Local Storage）**：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。
符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完，其中最重要的一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。
Java语言中，如果一个变量要被多线程访问，可以使用volatile关键字声明它为“易变的”；如果一个变量要被某个线程独享，Java中就没有类似C++中__declspec（thread）[3]这样的关键字，不过还是可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。

# 锁
多线程并发中，共享数据、保证数据一致性的工具。

## 隐式锁 synchronized
[java-Synchronized]()

## 显式锁 Lock 和 ReentrantLock 
加锁和解锁都是显式实现的。

## synchronized vs lock
java 的两种锁机制。在竞争条件下 ReentrantLock 的实现要比 synchronized 的实现更具有伸缩性。JDK1.6 之前，多线程环境下 synchronized 的吞吐量下降得非常严重，而 ReentrantLock 则能基本保持在同一个比较稳定的水平上。与其说 ReentrantLock 性能好，还不如说 synchronized 还有非常大的优化余地。
后续的技术发展也证明了这一点，JDK1.6 对 synchronized 优化措施效果明显，synchronized 与 ReentrantLock 的性能基本上是完全持平了。因此，性能因素不再是选择 ReentrantLock 的理由，虚拟机在未来的性能改进中肯定也会更加偏向于原生的 synchronized，所以还是提倡在 synchronized 能实现需求的情况下，优先考虑使用 synchronized 来进行同步。

### 用法上
synchronized：使用在需要同步的对象中，可以用在方法级别上，也可以加在特定代码块中，括号中表示需要锁的对象；
lock：需要显示指定起始和终止位置。一般就是使用 ReentrantLock 类作为锁，多个线程中必须要使用一个 ReentrantLoc 类作为对象才能保证锁的生效。而且在加锁和解锁处需要通过 lock() 和 unlock() 显式指出。所以一般要在 finally 块中写 unlock() 以防死锁。此外，ReentrantLoc 类提供了 2 种 竞争锁机制：公平锁和非公平锁。一般而言，非公平锁效率更高：公平锁需要维护线程队列顺序。

### 性能上
synchronized 是托管给 JVM 执行的，而 lock 是 java 写的控制锁的代码。synchronized 采用的是 CPU 悲观锁机制，即线程获得的是独占锁；而 lock 采用的是乐观锁机制，其实现就是 CAS。研究 ReentrantLock 源码可以发现，其中一个比较重要的获得锁的方法是 compareAndsetState()，这里就是调用的 CPU 提供的特殊指令支持。

### 用途上
一般情况下，两者没有显著区别。而在特殊的复杂并发同步问题中，如以下情况，则更适合 ReentrantLock：
* 某个线程在等待一个锁的控制权期间，需要中断；
* 需要分开处理一些 wait-notify，ReentrantLoc 里的 Condition 应用，能够控制 notify 特定线程；
* 具有公平锁功能，每个到来的线程都将排队等待。
{% asset_img synchronized-vs-lock.PNG synchronized vs lock %}

### 如何选择
JDK1.6 加入了对 synchronized 关键字的很多改进，使得两者在性能上差距已经不是很明显，加上后续的不断改进以及官方默认更倾向于鼓励用户使用它的态度，如果非要在二者之间选择，应该首选 synchronized。其能够提供更简洁的实现，这成了性能之外的另一优势，而且相比于需要显式管理的 Lock，显然出错的概率更小；然而，在解决特定问题，尤其是 synchronized 解决不了或者不易实现的情况下，如，尝试在一定时间/次数获取锁，如果不能获得则放弃，此时就要使用 juc 类库中的方法，包括 Lock。此外：
* 最好两个都不用，而是使用 JUC（java.util.concurrent）包提供的机制，能够帮助用户处理所有与锁相关的代码；
* 如果 synchronized 关键字能满足用户的需求，就用 synchronized，因为它能简化代码；
* 如果需要更高级的功能，就用 ReentrantLock 类，此时要注意及时释放锁，否则会出现死锁，通常在 finally 代码释放锁。

## 自旋锁/可重入锁
不仅仅在 java 语义下。

### 自旋锁
让当前线程不停地在循环体内执行（空循环），当循环条件被其他线程改变时（比如等待的锁被释放并收到通知）才能进入临界区。由于线程没有改变状态如阻塞挂起等，而是继续空循环以便快速响应，这将导致：当线程数量不断增加时，整体性能明显下降，因为每个线程都处于自旋状态，会白白浪费 CPU 时间等资源。所以适用于线程竞争不太激烈并且线程保持锁的时间相对较短的场景。此外，自旋锁有可能导致 **死锁**：当一个线程内两次调用请求某个锁时，第二次请求将在自旋上陷入死锁。

### 可重入锁
也称递归锁，指同一线程中，外层方法/函数获得锁之后，内层方法/函数即使仍然有获取该锁的操作，也无需再次申请锁（如果需要申请，此时也是不被允许的），而是直接可以进入该锁所同步着的代码块。
可重入锁最大的作用是 **避免死锁**：可避免上述自旋锁的死锁情况发生。但所有基于锁的实现都无可避免地可能产生死锁。可重入锁会在由于某些原因导致锁没有被正确释放（无论隐式锁还是显式锁，在遇到一些特殊情况会导致锁无法正常被释放）而导致死锁发生。

## 锁与无锁
### 基于锁的并发
优点：
1、编程模型简单，如果小心控制上锁顺序，一般来说不会有死锁的问题；
2、可以通过调节锁的粒度来调节性能。
缺点：
1、所有基于锁的算法都有死锁的可能；
2、上锁和解锁时进程要从用户态切换到内核态，并可能伴随有线程的调度、上下文切换等，开销比较重；
3、对共享数据的读与写之间会有互斥。

### 无锁编程（lock free）
常见的 lock free 编程一般是基于CAS(Compare And Swap)操作：CAS(void *ptr, Any oldValue, Any newValue);
即查看内存地址ptr处的值，如果为oldValue则将其改为newValue，并返回true，否则返回false。X86平台上的CAS操作一般是通过CPU的CMPXCHG指令来完成的。CPU在执行此指令时会首先锁住CPU总线，禁止其它核心对内存的访问，然后再查看或修改*ptr的值。简单的说CAS利用了CPU的硬件锁来实现对共享资源的串行使用。
优点：
1、开销较小：不需要进入内核，不需要切换线程；
2、没有死锁：总线锁最长持续为一次read+write的时间；
3、只有写操作需要使用CAS，读操作与串行代码完全相同，可实现读写不互斥。
缺点：
1、编程非常复杂，两行代码之间可能发生任何事，很多常识性的假设都不成立。
2、CAS模型覆盖的情况非常少，无法用CAS实现原子的复数操作。

### 对比
在性能层面上，CAS与mutex/readwrite lock各有千秋，简述如下：
1、单线程下CAS的开销大约为10次加法操作，mutex的上锁+解锁大约为20次加法操作，而readwrite lock的开销则更大一些。
2、CAS的性能为固定值，而mutex则可以通过改变临界区的大小来调节性能；
3、如果临界区中真正的修改操作只占一小部分，那么用CAS可以获得更大的并发度。
4、多核CPU中线程调度成本较高，此时更适合用CAS。
跳表和红黑树的性能相当，最主要的优势就是当调整(插入或删除)时，红黑树需要使用旋转来维护平衡性，这个操作需要动多个节点，在并发时候很难控制。而跳表插入或删除时只需定位后插入，插入时只需添加插入的那个节点及其多个层的复制，以及定位和插入的原子性维护。所以它更加可以利用CAS操作来进行无锁编程。

## 阻塞/非阻塞同步

### 阻塞同步
悲观并发策略。可以让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。
阻塞同步最大的问题还是在于线程状态转换导致的性能问题。
java 中，能够进入/退出 阻塞状态或包含阻塞锁的方法有 synchronized 关键字（其中的重量锁）、ReentrantLock、Object.wait()/notify()、LockSupport.park()/unpart()（JUC 经常使用)。

### 非阻塞同步
基于冲突检测的乐观并发策略，需要硬件支持（如 CAS）。通俗讲，就是先进行操作，如果没有其他线程争用共享数据，那么操作成功；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。
