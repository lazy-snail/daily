---
title: JVM-运行时数据区域
date: 2018-04-16 23:46:53
categories: java
tags: [java, JVM]
---
JVM 是基于栈的。
JVM 运行 java 程序过程中会把其管理的内存划分为若干不同用途的数据区域：它们的创建/销毁时间不尽相同，有的区域随 JVM 的启动而存在，有的则依赖于用户线程的启动/结束而建立/销毁。jvms 规定了以下运行时数据区域：
{% asset_img JVM运行时数据区.png JVM运行时数据区 %}

#### PC（Program Counter Register，程序计数器）
较小的一块内存空间，可以看作当前线程锁执行的字节码的行号指示器。JVM 概念模型里，字节码解释器工作时就是通过改变 PC 值来选取下一条需要执行的字节码指令。
每个线程都需要独立的 PC，即这类内存区域为“线程私有”的。
PC 是唯一一个在 jvms 中没有规定任何 OutOfMemoryError 情况的区域。

#### Java 虚拟机栈（Java VM Stacks）
也是线程私有的，其生命周期和线程相同。虚拟机栈描述的是 java 方法执行的内存模型：每个方法在执行的同时都会创建一个 **栈帧（Stack Frame）**，用于存储 **局部变量表**、**操作数栈**、**动态链接**、**方法出口** 等信息。**每个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。**
**栈帧**
方法运行时的基础数据结构，可以理解为一个方法的运行空间。由两部分组成：
* **局部变量表** 存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、方法参数、对象引用（reference 类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他于此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。其中，64 bit 长度的 long 和 double 会占用 2 个局部变量空间（Slot），其余类型占用 1 个。所以，局部变量表所需内存空间在编译期间就能完成分配。当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，方法运行期间不会改变局部变量表的大小。
* **操作数栈** 存放操作数。java 程序编译后的字节码指令的操作数都存放在这里。当执行某条带 n 个操作数的指令时，就从栈顶取出 n 个操作数，把指令计算结果（如果有）再入栈。_一般所谓的“JVM 执行引擎是基于栈”的时候，指的就是操作数栈。_

jvms 规定了该区域的两种异常：
* 如果线程请求的栈深度大于 VM 所允许的深度，将抛出 StackOverflowError 异常；
* 如果虚拟机栈可以动态扩展（当前大部分 jvm 都支持，但 jvms 也允许固定长度），而在扩展时无法申请到足够的内存，将抛出 OutOfMemoryError 异常。

#### 本地方法栈（Native Method Stacks）
与虚拟机栈作用相似，区别在于虚拟机栈为 VM 执行 java 方法（即字节码）服务，而本地方法栈为 VM 使用到的 Native 方法服务。jvms 没有对本地方法栈中方法使用的语言、使用方式、数据结构作任何强制规定，所以具体的 VM 可以自由实现它（如，Sun HotSpot 就直接把本地方法栈和虚拟机栈合二为一）。
异常情况也同虚拟机栈。

**以上 3 个数据区域随线程创建而创建，随线程终结而终结。**

#### Java 堆（Java Heap）
JVM 所管理的内存中最大的一块。被所有线程共享，在 VM 启动时创建。Java 堆的唯一目的就是存放 **对象实例**，几乎所有的对象都在这里分配内存。jvms 描述是：所有的对象实例以及数组都要在堆上分配（The heap is the run-time data area from which memory for all class instances & arrays is allocated）。但随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，这个规范也就显得渐渐不那么“绝对”了。
Java 堆是垃圾收集器管理（GC）的主要区域，因此也称为 **GC 堆，Garbage Collected Heap**。从不同角度出发，java 堆又可以做进一步的细分：
* 从内存分配角度看，线程共享的 java 堆中可能划分出多个 **线程私有的分配缓冲区（Thread Local Allocation Buffer， TLAB）**；
* 从内存回收角度看，由于现在的收集器基本都采用分代收集算法，所以 java 堆还可以划分为：新生代、老年代。再细致一点的还有： Eden 空间、From Survivor 空间、To Survivor 空间等。

_无论如何划分，java 堆存储的都仍然是对象实例。_
jvms 规定 java 堆可以处于物理上不连续的内存空间，只要逻辑上是连续的即可；既可以是固定大小的，也可以是可扩展的。当前主流 VM 都是按照可扩展来实现的（通过 -Xmx 和 -Xms）。
如果在堆中没有足够内存以完成实例分配，并且堆大小也无法再扩展时，将抛出 OutOfMemoryError 异常。

#### 方法区（Method Area）
与 java 堆一样，是被所有线程共享的内存区域，在 VM 启动时创建。用于存储已被 VM 加载的 **类信息、常量、静态变量、即时编译器编译后的代码等数据**。
虽然 jvms 将方法区描述为堆的一部分，但其别名叫做 Non-Heap（非堆），以示区别，没有对具体实现作约束。_JDK 1.8 之前，HotSpot 将方法区实现为永久代，1.8 之后取消永久代，替代的是 Metaspace，永久代中的 class metadata 转移到 native memory（本地内存）中，interned Strings 和 class static variables 转移到 java heap 中，永久代参数（PermSize MaxPermSize）替换为元空间参数（MetaspaceSize，MaxMetaspaceSize）。而其他 VM 如 BEA JRockit、IBM J9 等，本就没有永久代的概念。_
jvms 对方法区的描述比较宽松，同样不需要连续的物理内存，可固定大小，也可扩展，还可以选择不实现垃圾收集（相对而言，垃圾收集行为较少发生在方法区中）。
当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。

#### 运行时常量池（Runtime Constant Pool）
Class 文件中除了类版本、字段、方法、接口等描述信息，还有一项信息是 **常量池（Constant Pool Table）**，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。其中符号引用（Symbolic Reference）属于编译原理概念，包含三类常量：
* 类和接口的全限定名（Full Qualified Name）；
* 字段的名称和描述符（Descriptor）；
* 方法的名称和描述符。

运行时常量池相对于 Class 文件常量池的一个重要特征是具备动态性。即，java 语言并不要求常量一定在编译期间才能产生，运行期间也可能将新的常量放入其中。而 Class 文件对每一部分（包括常量池）的格式都有严格规定，每个字节用于存储哪种数据都必须符合规范。
作为方法区的一部分，当运行时常量池无法再申请到内存时将抛出 OutOfMemoryError 异常。

**运行时常量池位置变化**
这个问题牵扯较多，如果不清晰，可能会遇到一些难以理解的运行错误，如典型的 String 的 intern()方法。
首先明确一点，从上述可知，方法区逻辑上属于 java 堆，只不过涉及到 GC 等问题时，可以进行细化操作。而具体的运行时常量池位置则跟 JDK 版本和相应虚拟机（这里指内置的 HotSpot）有关。
* JDK1.6 及以前：HotSpot 将 GC 分代收集扩展到了方法区，主要回收目标是针对常量池和对类型的卸载，并使用永久代（PermGen）概念实现了方法区（这也是人们常称方法区为永久代的原因，但二者并不相同，观察的角度也不同：前者是 jvms 规范内存的逻辑划分，后者是 jvm 针对规范的具体实现），所以运行时常量池处在永久代中。此时 OOM 错误显示为 PermGen space 。
* JDK1.7：移到了 java 堆中。字符串常量池也在该版本移到 java 堆。也是从这个版本开始，也许是 Oracle 为了兼容收购来的 JRockit（没有永久代的概念） 和原本的 HotSpot，决定逐步移除 HotSpot 中的永久代。此时 OOM 错误显示为 Java heap space。__
* JDK1.8：彻底移除整个永久代，取而代之的是一个独立空间——metaspace（元空间），它独立于 java 堆，使用本地内存，所以不再有 OOM 错误，理论上大小只受到物理内存的限制。

**相关概念**
* 常量池表（Constant Pool Table)：
class 文件中存储所有常量（包括字符串）的表，这是 class 文件中的内容，其实就是其中的一部分字节码指令，跟“pool”、运行时概念不相关；

* 运行时常量池（Runtime Constant Pool）：
运行时的内容。大部分内容是随着 JVM 的运行，从常量池转化而来，每个 class 对应一个运行时常量池；

* 字符串常量池（String Pool）：
与运行时常量池不是一个概念，字符串常量池是 JVM 实例全局共享的，即，全局只有一个。jvms 规定进入这里的 String 实例叫做“被驻留的 interned string”，HotSpot 使用哈希表 String Table 来引用堆中的字符串实例，被引用就是被驻留。

* Metaspace（元空间）：
JDK8 HotSpot 使用本地内存来存储类的元数据信息，这块内存就是元空间。本质上，还是对应于 jvms 里的方法区，只不过实现上不再使用 java 堆的一部分（之前版本的方法区实现，也就是永久代，逻辑上属于 java 堆的一部分），而是直接使用本地内存，这意味着不再出现 OOM 错误。

#### 直接内存（Direct Memory）
并非 VM 运行时数据区的一部分，也不是 jvms 中定义的内存区域。
JDK 1.4 新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行进行操作。这样能在一些场景中显著提高性能，因为避免了在 java 堆 和 Native 堆中来回复制数据。
本机直接内存的分配不受 java 堆大小的限制，只跟本机物理内存等有关。但如果配置不当，也会造成动态扩展时物理内存已耗尽而抛出 OutOfMemoryError 异常。

#### JDK 1.8 中 HotSpot 内存模型
{% asset_img JDK1.8-HotSpot内存模型.png JDK1.8-HotSpot内存模型 %}
