---
title: 内存模型
date: 2018-06-04 21:32:49
categories: java
tags: [java, JVM]
---
[toc]
**java 内存模型**

## 相关问题。
### 高速缓存机制
目前，CPU 的运算速度比计算机存储设备有几个数量级的差距，所以现代计算机都有一层（三层）读写速度尽可能接近处理器的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步
回内存之中，这样处理器就无须等待缓慢的内存读写了。
基于高速缓存的存储交互很好地解决了处理器与内存之间的矛盾，但也为计算机体系架构设计带来了更高的复杂度，因为引入了一个新的问题：缓存一致性（Cache Coherence）：
在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主存（Main Memory），当多个处理器的运算任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致，此时，同步回主存的数据以谁为准呢？
为解决这种不一致，需要各个处理器访问缓存时都遵循一些协议来保证读写操作的正确性。这类协议有 MSI、MESI、MOSI、Synapse、Firefly、Dragon Protocol 等。而 **内存模型**，即可以理解为在特定的操作协议下，对特定的内存/高速缓存进行读写访问的过程抽象。
不同架构的物理机器可以有不同的内存模型，jvm 拥有自己的内存模型。
{% asset_img 物理高速缓存模型.png 高速缓存交互关系 %}

### 重排序问题
为使得处理器内部运算单元尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但 **不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致**。因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，jvm 的即时编译器也有类似的指令重排（Instruction Reorder）优化。


## jvm 内存模型
jvms 定义的 java 内存模型（Java Memory Model，JMM），试图屏蔽掉各种硬件和 OS 的内存访问差异，以实现让 java 程序在各种平台下都能达到一致的内存访问效果，目前已臻至成熟。
JMM 规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与上述物理硬件的主内存名字一样，两者也可以互相类比，但此处仅是 jvm 内存的一部分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。
{% asset_img java内存模型.png java内存模型交互关系 %}
这里所讲的主内存、工作内存 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。

### 内存间交互操作
JMM 规定了以下 8 种操作，来完成主内存和工作内存之间具体的交互协议——即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节：
* lock（锁定）：作用于主内存变量，它把一个变量标识为仅能被一条线程独占的状态；
* unlock（解锁）：作用于主内存变量，它把一个处于锁定状态的变量释放出来，释放后的变量可以被其他线程访问/锁定；
* read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后续的 load 操作使用；
* load（载入）：作用于工作内存的变量，它把 read 操作从主内存得到的变量值放入工作内存的变量副本中；
* use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；
* assgin（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作；
* store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传回到主内存中，以便后续的 write 操作使用；
* write（写入）：作用于主内存变量，它把 store 操作从工作内存中得到的变量的值放入到主内存的变量中。
如果要把一个变量从主内存复制到工作内存，那就要顺序地执行 read 和 load 操作，如果要把变量从工作内存同步回主内存，就要顺序地执行 store 和 write 操作。注意，JMM 只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说，read 与 load 之间、store 与 write 之间是可插入其他指令的。

此外，JMM 还规定了在执行上述 8 种基本操作时必须满足如下规则：
* 不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现；
* 不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存；
* 不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中；
* 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量。换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。
* 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁；
* 如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值；
* 如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量；
* 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）。

**8 种内存访问操作和上述规则限定，再加上对 volatile 关键字的一些特殊规定，就已经完全确定了 Java 程序中哪些内存访问操作在并发下是安全的**。
以上定义严谨但繁琐，其有一个等效判断原则——**先行发生原则**，也同样能够确定一个访问在并发环境下是否安全。

### volatile 规则
关键字 volatile 可以被认为是 jvm 提供的最轻量级的同步机制。volatile 变量在各个线程的工作内存中不存在一致性问题：在各个线程的工作内存中，volatile 变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题。
当一个变量被定义为 volatile 后，它具备两个特性：
* 保证此变量对所有线程的可见性。
这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。（回想普通变量，其值在线程间传递均需要通过主内存来完成，例如，线程 A 修改一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程 A 回写完成了之后再从主内存进行读取操作，新变量值才会对线程 B 可见）。但可见性并不意味着线程安全，事实上，volatile 并不是线程安全的，它并不能保证操作符合原子性。所以在一些有依赖的运算中，仍然要通过加锁（使用 synchronized 或 java.util.concurrent 中的原子类）来保证原子性。
* 禁止指令重排序优化。
普通变量仅保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不保证变量赋值操作的顺序与程序代码中的执行顺序一致。而在一个线程的方法执行过程中无法感知到这点，这也就是 JMM 描述的所谓“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。
从硬件上讲，指令重排不是以指令顺序任意执行，而是 CPU 在正确处理 **依赖情况** 的前提下，可能会将没有依赖关系的指令（来自于代码汇编的字节码）不按程序中代码顺序分开发送给相应电路单元进行处理，并且保证在后续有对之前的操作结果有依赖的地方能够取到正确的值，这样从最终结果上看依然是像有序执行的结果；而有依赖关系的代码指令之间不能重排。
volatile 能够禁止指令的重排优化，通过汇编代码可见，有 volatile 修饰的变量在执行操作后，会多执行一句 “lock addl 
$0x0，(%esp)”指令（把 ESP 寄存器的值加 0，显然是一个空操作），这相当于一道内存屏障使得指令重排序无法逾越，关键就在于其 lock 前缀，它的作用是使得本 CPU 的 Cache 写入内存，同时该写入动作会引起别的 CPU 或者别的内核无效化（Invalidate）其 Cache，即相当于对 Cache 中的变量做了一次 JMM 中的“store和write”操作。所以通过这样一个空操作，可让 volatile 变量的修改对其他 CPU 立即可见。

#### volatile vs 锁
显然，volatile 并不等同于安全的锁，它也无法在多线程中保证安全性，但在特定场景下依然能够提供“足够的安全性”且比锁（synchronized 关键字或 java.util.concurrent 包里面的锁）效率更高。但随着 jvm 对锁的各种优化策略的进步——锁消除、锁粗化等，已无法简单定量分析究竟孰优孰劣。而如果让 volatile 自身对比，那可以确定一个原则：volatile 变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile 的总开销仍然要比锁低，我们在 volatile 与锁之中选择的唯一依据应该是 **volatile 的语义能否满足使用场景的需求**。
**使用场景（满足以下条件时使用）**
* 对变量的写操作不依赖变量的当前值或其他的变量，或者能确保只有单个线程更新变量值；
* 该变量不会与其他状态变量一起纳入不变性条件中；
* 在访问变量时不需要加锁。

### long 和 double 
对于 64 位的数据类型（long 和 double），JMM 规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现不保证 64 位数据类型的 load、store、read、write 这 4 个操作的原子性——但同时强烈建议 jvm 保证其操作的原子性，所以目前多数商用 jvm 都选择把 64 位数据的读写操作作为原子操作对待来实现。

### 原子性、可见性、有序性
JMM 是围绕在并发过程中如何处理原子性、可见性和有序性这 3 个特性而建立起来的。

#### 原子性 Atomicity
JMM 直接保证基本数据类型（64 位的姑且也可以包含在内）的读写访问（read、load、assign、use、store
、write）具备原子性。如果场景需要更大范围的原子性保证（经常发生），JMM 提供 lock、unlock 操作来满足这种需求。jvm 并没有把这两个操作直接暴露给用户，而是提供了更高层次的字节码指令：monitorenter 和 monitorexit 来隐式使用这两个操作。这两个字节码指令反映到 java 代码中就是同步块——synchronized 关键字，因此在 synchronized 块之间的操作也具备原子性。

#### 可见性 Visibility
当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。**JMM 通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性**。无论普通变量还是 volatile 变量都是如此，不同在于：volatile 的特殊规则保证了新值能够立即同步到主内存并且每次使用前立即从主内存刷新，从而保证了多线程操作中变量的可见性。
除了 volatile 之外，synchronized 和 final也能保证可见性。同步块的可见性由“对一个变量执行 unlock 操作之前，必须把它同步回主内存中（执行 store、write 操作）”这条规则获得的；而 final 关键字的可见性是指：被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this 引用逃逸是危险操作，其他线程有可能通过这个引用访问到”初始化了一半”的对象），那么在其他线程中就能看见 final 字段的值，并且无须同步就能被线程正确访问。

#### 有序性 Ordering
如果在本线程观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为穿行的语义（Within-Thread As-If-Serial Semantics）”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。这是 java 程序中天然的有序性。
java 语言提供了 volatile 和 synchronized 关键字来保证线程之间操作的有序性，volatile 本身就包含了禁止对指令重排序的语义，而 synchronized 由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得有序性保证——该规则决定了持有同一个锁的两个同步块只能串行地进入。

可见，synchronized 关键字在需要以上 3 种特性的时候都可以作为一种解决方案，事实上也是如此：大部分并发控制操作都可以使用它来完成。但滥用以及本可以考虑其他更优的方式而仍然选择使用 synchronized，也将导致性能和效率的不同程度降低。

### Happen-Before 原则
先行发生原则，JMM 定义的两项操作之间的偏序关系，是判断数据是否存在竞争、线程是否安全的主要依据：如果操作 A 先行发生于操作 B，i.e. 操作 A 发生在操作 B 之前，那么操作 A 产生的影响（应该保证）能被操作 B 观察到，“影响”包括修改了共享内存中变量的值、发送了消息、调用了方法等。
以下为 JMM 天然存在的 Happen-Before 关系，这些先行发生关系无须任何同步器协助就能正常执行，即在编码过程中直接使用，并且如果两个操作之间的关系不在下述范围之列，或者无法从下述条目推导得出，那么它们就没有顺序性保证，jvm 就可以对它们进行重排序：
* 程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作（更准确的说法是控制流顺序而不是代码顺序，因为有分支、循环等结构）；
* 管程锁定规则（Monitor Lock Rule）：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里强调同一个锁，而“后面”是指时间上的先后顺序；
* volatile 变量规则（Volatile Variable Rule）：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。这里的“后面”同样是指时间上的先后顺序；
* 线程启动规则（Thread Start Rule）：Thread 对象的 start() 方法先行于此线程的每一个动作；
* 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，可以通过 Thread.join()方法的结束、Thread.isAlive()的返回值等手段检测到线程是否已经终止；
* 线程中断规则（Thread Interruption Rule）：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted()方法检测到线程是否有中断发生；
* 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize()方法的开始；
* 传递性（Transitivity）：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么可以得出结论：操作 A 先行发生于 操作 C。
可以根据以上规则判定一端代码是否可以保持线程安全，即是否需要采取线程安全的措施。

_“时间上的先发生”和“先行发生”之间并没有推导关系，见书上关于 setter()&getter() 和 重排序的例子。_
