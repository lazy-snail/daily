---
title: 内存模型
date: 2018-06-04 21:32:49
categories: java
tags: [java, JVM]
---
[toc]
**java 内存模型**

## 相关问题。
### 高速缓存机制
目前，CPU 的运算速度比计算机存储设备有几个数量级的差距，所以现代计算机都有一层（三层）读写速度尽可能接近处理器的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步
回内存之中，这样处理器就无须等待缓慢的内存读写了。
基于高速缓存的存储交互很好地解决了处理器与内存之间的矛盾，但也为计算机体系架构设计带来了更高的复杂度，因为引入了一个新的问题：缓存一致性（Cache Coherence）：
在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主存（Main Memory），当多个处理器的运算任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致，此时，同步回主存的数据以谁为准呢？
为解决这种不一致，需要各个处理器访问缓存时都遵循一些协议来保证读写操作的正确性。这类协议有 MSI、MESI、MOSI、Synapse、Firefly、Dragon Protocol 等。而 **内存模型**，即可以理解为在特定的操作协议下，对特定的内存/高速缓存进行读写访问的过程抽象。
不同架构的物理机器可以有不同的内存模型，jvm 拥有自己的内存模型。
{% asset_img 物理高速缓存模型.png 高速缓存交互关系 %}

### 重排序问题
为使得处理器内部运算单元尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但 **不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致**。因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，jvm 的即时编译器也有类似的指令重排（Instruction Reorder）优化。

## jvm 内存模型
jvms 定义的 java 内存模型（Java Memory Model，JMM），试图屏蔽掉各种硬件和 OS 的内存访问差异，以实现让 java 程序在各种平台下都能达到一致的内存访问效果，目前已臻至成熟。
JMM 规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与上述物理硬件的主内存名字一样，两者也可以互相类比，但此处仅是 jvm 内存的一部分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。
{% asset_img java内存模型.png java内存模型交互关系 %}
这里所讲的主内存、工作内存 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。

### 内存间交互操作
JMM 规定了以下 8 种操作，来完成主内存和工作内存之间具体的交互协议——即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节：
* lock（锁定）：作用于主内存变量，它把一个变量标识为仅能被一条线程独占的状态；
* unlock（解锁）：作用于主内存变量，它把一个处于锁定状态的变量释放出来，释放后的变量可以被其他线程访问/锁定；
* read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后续的 load 操作使用；
* 