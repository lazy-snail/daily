---
title: GC算法
date: 2018-04-25 09:37:21
categories: java
tags: [java, JVM]
---
GC 算法的实现涉及大量的程序细节，且各个平台上的 JVM 操作内存的方法也不相同，所以算法的具体实现有很大差异。但策略思想是通用的。

# 判断对象存活状态
GC 面临的首要问题是，如何判断对象是否存活，即是否可以被回收？常见方法有引用计数法、可达性分析等。

## 引用计数
Reference Counting
给对象添加一个引用计数器，每当有一个地方引用它时，计数器就 +1，当引用失效时，计数器就 -1，计数器为 0 的对象就是不能再被使用的，即可被回收。
尽管该算法理论上实现简单、判定效率高，但它无法解决一个很重要的问题：无法解决对象之间的相互循环引用问题。从而没有进入大多数主流商用 JVM。

## 可达性分析
Reachability Analysis
主流程序语言判定对象是否存活的常用算法实现。基本思路就是通过一系列被称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所经过的路径被称为“引用链（Reference Chain）”，当一个对象到 GC Roots 没有任何引用链相连（即，GC Roots 到 该对象不可达）时，就证明该对象是不可用的，即可被回收。
{% asset_img 可达性分析.png 可达性分析 %}
可作为 GC Roots 的对象主要在全局性的引用（如常量和类静态属性）与执行上下文（如栈帧中的本地变量）中，一般有：
* 虚拟机栈（栈帧中的本地变量表）中引用的对象；
* 方法区中类静态属性引用的对象；
* 方法区中常量引用的对象；
* 本地方法栈中 JNI（即一般所说的 Native 方法）引用的对象。

**两次标记过程**
即使在可达性分析算法中不可达的对象，也不会立即被回收。而真正回收一个对象，需要经历至少两次标记过程：
1. 在可达性分析后发现该对象不可达，则对该对象进行第一次标记并进行一次筛选。筛选的条件是该对象是否有必要执行 finalize() 方法：当对象没有覆盖 finalize() 方法或 finalize() 方法已经被 JVM 调用过，这两种情况都视为“没有必要执行”。
2. 如果该对象被判定为有必要执行 finalize() 方法，那么该对象就会被放置在一个叫做 F-Queue 的队列中，并在稍后由一个由 JVM 自动建立的、优先级较低的 Finalizer 线程去执行它（仅仅触发对象的 finalize() 方法，而不一定会等待该方法执行结束——可能该方法根本不会结束）。finalize() 方法是对象逃脱死亡命运的最后一次机会——如果在该方法中重新建立引用链，那么在第二次标记时该对象将被移出“即将回收”集合。

**方法区 GC**
判定一个常量是否是“废弃常量”比较简单：没有任何对象引用这个常量。而判定一个“无用的类”，需要同时满足以下条件：
* 该类的所有实例都已经被回收，即，java 堆中不存在该类的任何实例；
* 加载该类的 ClassLoader 已经被回收；
* 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。


# GC 算法
解决如何筛选可回收资源问题之后，下一步就是确定垃圾回收的具体实现。最基础的就是“标记-回收”算法，其他很多算法基于此进行改进。

## 标记-清除
Mark-Sweep
{% asset_img 标记-清除算法.PNG 标记-清除算法 %}
最基础的回收算法——后续的回收算法都是基于这种思路并在某些方面加以改进。
算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，完成后统一回收所有被标记的对象。
基础的实现存在一些问题：
* 效率上，标记和清除两个过程的效率都不高；
* 空间上，标记-清除之后会产生大量内存碎片，可能导致后续的对象无法完成内存分配，从而更为频繁地触发垃圾回收。

## 复制（Copying）
{% asset_img 复制算法.PNG 复制算法 %}
为解决效率问题，将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当正在使用的内存块用完了，就将仍存活的对象复制到另一块上去，然后清理该内存块。这样使得每次都是对半块内存进行回收，分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。
实现简单，运行高效，缺点也很明显：可用内存小于整个配置内存的一半。一般不会直接采用这种算法。

## 改进的复制算法
{% asset_img 改进的复制算法.PNG 改进的复制算法 %}
IBM 研究表明，新生代中的对象 98% 是“朝生夕死”的，所以不需要按照 1:1 来划分内存空间。而是，如 HotSpot 等 JVM 实现（一开始就没有通过 1:1 模式实现，分代方式从最初就是这样的布局），按照 8:1:1 划分为一快较大的 Eden 空间和两块等大的较小的 Survivor 空间。每次使用 Eden 空间和其中一块 Survivor 空间，当发生回收时，将 Eden 和在用的 Survivor 中的存活对象一次性复制到另一块 Survivor 空间中，然后清理 Eden 空间和复制转移存活对象后的 Survivor 空间。
显然，可能发生 Survivor 空间不够用的情况，这时需要依赖其他内存（如老年代）进行分配担保（Handle Promotion）。而且，存活率较高时，需要较多的复制操作，效率问题依然存在。

### 标记-整理
Mark-Compact
{% asset_img 标记-整理算法.PNG 标记-整理算法 %}
根据老年代的特点，提出“标记-整理”算法。标记过程同“标记-清除”算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理端边界以外的内存。

# 分代收集
Generational Collection
当前商业 JVM 的 GC 都采用的算法，本质上是为了优化 GC 效率性能。根据对象存活周期的不同，将内存划分为几块：一般把 java 堆分为新生代和老年代，这样就可以根据各个年代的特点进行采用更适当的 GC 算法。在新生代中，每次 GC 时都发现有大量对象死去，只有少量继续存活，那么就使用复制算法——只需要复制少量存活对象就可以完成 GC；而老年代中因为对象存活率较高，又没有额外空间对它进行分配担保，就必须使用“标记-清除”或“标记-整理”算法。可见，分代是对所讨论 GC 算法的一种细粒度的复合使用。
{% asset_img young_gc.png "新生代 GC" %}

