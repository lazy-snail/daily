---
title: 类文件结构
date: 2018-04-27 23:04:54
categories: java
tags: [java , JVM]
---
### 平台无关性的基石
**各种不同平台的 VM 与所有平台统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石。**
然而，VM 的目标显然不止于平台无关，其语言无关性也同样在发展：目前已经有 Groovy、Jython、JRuby、Scala 等语言同样能够运行在 JVM 上。而实现语言无关性的基础仍然是 VM 和字节码存储格式。JVM 不和包括 java 在内的任何语言绑定，它只和“class 文件”这种特定格式的二进制文件格式所关联，其中包含了 JVM 指令集和符号表以及若干其他辅助信息。任何其他语言同样可以使用合适的编译器将其代码编译为 class 文件从而在 JVM 上执行，JVM 本身不关心 class 文件来源于何种语言——只要该 class 文件符合 jvms 的语法和结构化约束即可。
字节码所能提供的语义描述能力强于 java 语言。

### class 类文件的结构
以 8-byte 为单位紧凑排列，大端字节序方式，不含任何分隔符，格式是严格定义的：数据项顺序、数量，字节序，哪个字节代表什么含义等等，都不允许改变。
文件格式采用类似于 C 语言结构体的伪结构，只含有两种数据类型：**无符号数和表**。
* 无符号数：基本数据类型，以 u1、u2、u4、u8 表示 1/2/4/8 个字节的无符号数。可以用来描述数字、索引引用、数量值或按照 UTF-8 编码构成字符串值；
* 表是由多个无符号数或其他表作为数据项构成的复合数据类型。所有表习惯性以“\_info”结尾。用于描述有层次关系的复合结构的数据。整个 class 文件本质上就是一张表。数据项：
{% asset_img class文件格式.PNG class文件格式 %}

无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。

#### 魔数与 class 文件版本
每个 class 文件前 4 个字节称为魔数（Magic Number），唯一作用是确定该文件是不是一个能被 JVM 接受的 class 文件。_很多文件存储标准中都是用魔数进行身份识别，如图片格式（gif、jpeg等都在头文件中存有魔数），魔数值可以由文件制定者自由选取，但要避免引起混淆_。使用魔数而非扩展名是基于安全性方面的考虑：扩展名可随意改动。class 文件的魔数值为：0xCAFEBABE（咖啡宝贝？），这个值在 java 还称作“Oak”语言的时候（1991年前后）就已经确定下来了。
紧接着魔数的 4 个字节存储的是 class 文件的版本号：5~6 字节是次版本号（Minor Version），7~8 字节是主版本号（Major Version）。Java 的版本号是从 45 开始的（JDK 1.xxx 为 45.xxx，而 JDK 1.8 为 52.xxx），JDK 1.1 之后的每个 JDK 大版本发布时，主版本号向上 +1（JDK 1.0~1.1 使用了 45.0~45.3 的版本号），高版本的 JDK 能向下兼容以前版本的 class 文件，但不能运行以后版本的 class 文件，即使文件格式未发生任何变化，JVM 也必须拒绝执行超过其版本号的 class 文件。

#### 常量池（Constant Pool）
紧接着主次版本号之后的是常量池入口，常量池可以理解为 class 文件中的资源仓库，是 class 文件结构中与其他项目关联最多的数据类型，也是占用 class 文件空间最大的数据项之一，也是 class 文件中第一个出现的表类型数据项目。
与 java 语言习惯不一样的是，常量池的容量计数器是从 1 而不是 0 开始的：为了满足某些索引在特定情况下需要表达“不引用任何一个常量池项目”的含义时，可以将索引值置 0。故总数量为 计数器值 - 1。class 文件中只有常量池的容量计数器是从 1 开始的。
常量池主要存放两大类常量：
* 字面量（Literal）：接近于 java 语言层面的常量概念，如文本字符串、声明为 final 的常量值等；
* 符号引用（Symbolic References）：属于编译原理方面的概念，包含以下 3 类常量：
> 类和接口的全限定名（Fully Qualified Name）
> 字段的名称和描述符（Descriptor）
> 方法的名称和描述符

class 文件中不保存各个方法、字段的内存布局信息，当 JVM 运行时，需要从常量池获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中。

常量池中每一项常量都是一个表。目前（JDK1.8)共有 14 种结构各异的表数据结构（有 3 种新增于 JDK1.7，为更好地支持动态语言调用）。
{% asset_img 常量池项目类型.PNG 常量池项目类型 %}
这 14 种 表都有一个共同特点：起始位置的 u1 标志位，代表当前这个常量属于哪种常量类型。每种常量项目的结构表如下：
{% asset_img 常量项的结构总表.png 常量项的结构总表 %}

#### 访问标志（Access flags）
常量池结束之后，紧接着的是 2 字节的访问标志。当前已使用了 8 位，其余位置 0：
{% asset_img 访问标志.PNG 访问标志 %}

#### 类索引、父类索引、接口索引集合
类索引（this_class）、父类索引（super_class）是 2 字节，各自指向一个类型为 CONSTANT_Class_info 的类描述符常量；接口索引集合（interfaces）是一组 2 字节类型的数据的集合，入口是 u2 类型的接口计数器，如果该类没有实现任何接口，则置 0，后面的接口索引表不再占用任何字节。
这 3 项数据用来确定这个类的继承关系：
* 类索引：确定该类的全限定名；
* 父类索引：确定该类的父类的全限定名（java 不允许多继承，故只有一个，除了 Object 类，其余都有父类）；
* 接口索引集合：描述该类实现了哪些接口，按 implements（如果这个类本身是接口，则是 extends）语句后的接口顺序排列。

#### 字段表（field_info）集合
用于描述接口/类中声明的变量。字段包括类级变量和实例级变量，但不包括在方法内部声明的局部变量。一个字段可以包括的信息有：字段的作用域（public、private、protected），实例变量还是类变量（static），可变性（final），并发可见性（volatile，是否强制从主内存读写），可否被序列化（transient），字段数据类型（基本类型、对象、数组）、字段名称。字段表结构如下：
{% asset_img 字段表结构.PNG 字段表结构 %}

其中，**字段访问标志（access_flags）** 与类中的 access_flags 类似：
{% asset_img 字段访问标志.PNG 字段访问标志 %}

跟随在 access_flags 的是两项索引值：**name_index 和 descriptor_index**，它们是对常量池的引用，分别代表着字段的简单名称、字段和方法的描述符。

{% codeblock HelloWorld.java lang:java  %}
package io.neil.hust;
public class HelloWorld {
    private String str = "Hello, World";
    public void sayHello(String str) {
        System.out.println(str);
    }
}
{% endcodeblock %}
* 全限定名：“io/neil/hust/HelloWorld”是"HelloWorld"类的全限定名（仅仅是把类全名“io.neil.hust.HelloWorld”的“.”换成了“/”）；
* 简单名称：没有类型和参数修饰的方法或字段名称：sayHello()方法和 str 字段的简单名分别为“sayHello”和“str”；
* 字段和方法的描述符：描述字段的数据类型、方法的参数列表（数量、类型、顺序）和返回值。其标识字符含义如下：
{% asset_img 描述符标识字符含义.PNG 描述符标识字符含义 %}

字段表都包含的固定数据项目到descriptor_index为止，之后跟随一个 **属
性表(attribute_info)集合** 用于存储一些额外的信息，字段都可以在属性表中描述零至多项的额外信息。

字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。

#### 方法表（method_info）集合
class 文件格式对方法的描述和对字段的描述几乎完全一致，仅在访问标志和属性表集合的可选项中有所区别。
**方法表访问标志**
{%asset_img 方法表访问标志.PNG 方法表访问标志 %}

#### 属性表（attribute_info）集合
class 文件、字段表、方法表都可以携带自己的属性表集合，用以描述某些场景专有的信息。
与 class 文件中其他数据项要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松：不要求各个属性表之间遵循严格顺序，只要不和已有属性名重复，任何自定义编译器都可以自定义属性信息。而 JVM 运行时会忽略它不认识的属性。为了能正确解析 class 文件，jvms 7 预定义了 21 项属性（目前的 jvms 10 为 26 项），这里以 jvms 10 为例。
{%asset_img JVMS预定义属性表.png JVMS预定义属性表 %}

对每个属性，它的名称需要从常量池中引用一个 CONSTANT_uTF8_info 类型的常量来表示，而属性值的结构则完全是自定义的，只需要通过一个 u4 的长度属性说明所占用的位数即可：
{%asset_img 属性表结构.PNG 属性表结构 %}

介绍几个重要的属性。
**Code 属性**
java 程序方法体中的代码经过 javac 编译器处理后，最终变为字节码指令存储在 Code 属性内，Code 属性出现在方法表的属性集合中，但并非所有方法都必须存在这个属性：接口/抽象类的方法可能就不存在。
{Code 属性表结构}
详见《深入理解java虚拟机》

### 字节码指令
JVM 采用面向操作数栈而不是寄存器的架构。

**class 文件格式所具备的平台独立特性和可动态扩展，是 java 技术体系实现平台无关、语言无关的重要支柱。**
