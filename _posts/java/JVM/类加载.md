---
title: Java-类加载
date: 2018-04-25 09:19:25
categories: java
tags: [java, JVM]
---
JVM 把描述类的数据从 class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被 JVM 直接使用的 java 类型，这就是 JVM 的类加载机制。
java 中，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略为应用程序提供了高度的灵活性。

### 类加载时机
类从被加载到 JVM 内存中开始，到卸载出内存为止，整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）。其中，验证、准备、解析 3 部分统称为连接（Linking）：
{% asset_img 类生命周期.png 类生命周期 %}

其中，加载、验证、准备、初始化、卸载这 5 个阶段的顺序是确定的（但并非串行，通常是交叉混合式进行的，只是开始执行的顺序是确定的），而解析在某些情况下可能在初始化阶段之后再开始：为了支持 java 的运行时绑定（也称动态绑定/晚期绑定）。
jvms 规定了 5 种情况下，才能对类立即进行“初始化”：
* 遇到 new、getstatic、putstatic、invokestatic 这4条字节码指令时，如果类没有进行过初始化，则先触发其初始化。常见场景是：使用 new 关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）、调用一个类的静态方法；
* 使用 java.lang.reflect 包的放方法对类进行反射调用时，如果类没有进行过初始化，则先触发其初始化；
* 初始化一个类时，如果发现其父类没有进行过初始化，则先触发其父类的初始化；
* JVM 启动时，用户需要指定一个要执行的主类，JVM 会先初始化该主类；
* 使用JDK 1.7+ 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果是 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则先触发其初始化。

### 类加载过程
#### 加载
“加载”是“类加载（Class Loading）”的一个阶段，jvms 规范要求这一阶段需要完成以下工作：
1. 通过一个类的全限定名来获取定义此类的二进制字节流；
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

该阶段用户应用程序可以通过自定义类加载器参与，类加载其余过程由 JVM 主导并控制。

#### 验证
是为了确保 class 文件的字节流中包含的信息符合当前 JVM 的要求，并且不会危害 JVM 自身的安全。是连接阶段的第一步。
主要包括：
1. 文件格式验证，魔数、版本、常量池中常量是否被支持、是否含有 utf-8 以外的编码格式...
2. 元数据验证，对字节码描述信息进行语义分析校验，可能包括：该类是否有父类；父类是否继承了不允许继承的类（final 修饰的类）；如果不是抽象类，是否实现了父类/接口必须实现的所有方法；字段、方法是否与父类产生矛盾...
3. 字节码验证，最复杂的验证阶段：通过数据流和控制流分析，确保程序语义合法、合乎逻辑；
4. 符号引用验证，JVM 将符号引用转化为直接引用，该校验发生在解析阶段。

#### 准备
正式为类变量分配内存并设置类变量初始值（一般就是零值），这些变量所使用的内存都在方法区中分配：仅包括类变量（static 修饰）而不包括实例变量，实例变量将在对象实例化时随着对象一起分配在 java 堆中。

#### 解析
JVM 将常量池内的符号引用替换为直接引用的过程。解析阶段的两者含义：
* 符号引用（Symbolic References）：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。
* 可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。

#### 初始化
类加载过程的最后一步。

### 类加载器
类加载阶段中的“通过一个类的全限定名来获取定义此类的二进制字节流”这个动作是在 JVMS 外实现的，实现这个动作的代码模块称为"类加载器"。
从 JVM 角度看，只存在两种类加载器：
* 启动类加载器（Bootstrap ClassLoader），JVM 自身的一部分，C++ 实现；
* 所有其他的类加载器，独立于 JVM，java 实现，并全部继承自抽象类 java.lang.ClassLoader。

从开发人员角度看，绝大部分 java 程序会使用到以下 3 种系统提供的类加载器：
* 启动类加载器（Bootstrap ClassLoader）；
* 扩展类加载器（Extension ClassLoader）,这个加载器由sun.misc.Launcher $ExtClassLoader实现，它负责
加载＜JAVA_HOME＞\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直
接使用扩展类加载器；
* 应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher $App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

{% asset_img 类加载器双亲委派模型.png 类加载器双亲委派模型 %}
