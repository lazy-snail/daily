---
title: Java-线程
date: 2018-04-14 15:39:53
categories: java
tags: [java, 并发]
---
[toc]
## java 线程
 线程是 java 程序执行的基本模型，也被成为轻量级进程。所有 java 程序至少由一个控制线程组成——即使一个只有 main( ) 函数的程序也是在 JVM 中作为一个线程运行的。
线程允许在同一个进程中同时存在多个程序控制流。共享进程范围内的一些资源：堆资源、内存句柄、文件句柄等；但线程拥有自己的程序计数器（PC）、栈、局部变量等。
大多数现代 OS 中，都是以线程为基本的调度单位，而不是进程。

**竞态条件**
当某个计算的正确性取决于多个线程的交替执行时序时，即，正确的结果要取决于运气。如，常见的竞态条件“先检查后执行（Check-Then-Act）”操作，即，通过一个可能失效的观测结果再来决定下一步的动作。

**活跃性**
关注的目标是：某件正确的事情最终会发生。活跃性问题包括死锁、饥饿、活锁等。

**停止线程的方法**
* 使用退出标志，即当 run() 方法完成后线程终止，属于正常退出；
* 使用 interrupt() 方法，中断线程；
* _stop()、suspend()、resume()都是作废过期的方法，会产生不可预料的结果，不建议使用。_

Java 中线程实现同步的方式主要是关键字 synchronized，它提供了一种独占的加锁方式；同时，“同步”这个术语还包括 volatile 类型变量，显式锁（Explicit Lock）、原子变量。

线程安全包含 **原子性** 和 **可见性** 两个方面，java的同步机制都是围绕这两个方面来确保线程安全的。
可见性在内存模型中遇到的同步问题有：
* 在编译器中生成的指令顺序，可能与源代码中的顺序不同；
* 编译器会把变量保存到寄存器而不是内存中；
* 处理器可以采用乱序/并行等方式来执行指令；
* 缓存可能会改变将写入变量提交到主内存的次序；
* 保存在处理器本地缓存中的值，对于其他处理器是不可见的；
etc.

这些因素会使得一个线程无法看到变量的最新值，并且会导致其他线程中的内存操作似乎在乱序执行——如果没有使用正确的同步。

### volatile
见 _java 内存模型_

### synchronized vs volatile
* volatile 是线程同步的轻量级实现，所以 volatile 性能比 synchronized 要好，并且 volatile 只能用于修饰变量，而 synchronized 可以修饰方法、代码块。目前 synchronized 在执行效率上提升明显，使用频率在增大；
* 多线程访问 volatile 不会发生阻塞，而 synchronized 会发生阻塞；
* volatile 能保证数据的可见性，但不保证原子性；synchronized 可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步；
* volatile 解决的是变量在多个线程之间的可见性，synchronized 解决的是多个线程之间访问资源的同步性。

### 显式锁 ReentrantLock
Lock 接口：提供了一种无条件的、可轮询的、定时的、可中断的锁获取操作，所有加锁和解锁的方法都是显式的。其实现提供与内部锁相同的内存可见性语义，但在加锁语义、调度算法、顺序保证、性能特性等方面可以有所不同。
ReentrantLoc 实现了 Lock 接口，并提供了与 synchronized 相同的互斥性、内存可见性、可重入的加锁语义。

**局限性**
如果没有使用 finally 来释放 try-catch 块中的 Lock，将很难追踪到最初发生错误的位置，因为没有记录应该释放锁的位置和时间。这就是 ReentrantLock 不能完全替代 synchronized 的原因：它更加危险，在程序的执行控制离开被保护的代码块时，不会自动清除锁——finally 是解决办法，但可能被忘记。

**在使用某种形式的加锁时，都要考虑出现异常时的情况。**

### synchronized vs lock
java 的两种锁机制。
**用法上**
synchronized：使用在需要同步的对象中，可以用在方法级别上，也可以加在特定代码块中，括号中表示需要锁的对象；
lock：需要显示指定起始和终止位置。一般就是使用 ReentrantLock 类作为锁，多个线程中必须要使用一个 ReentrantLoc 类作为对象才能保证锁的生效。而且在加锁和解锁处需要通过 lock() 和 unlock() 显式指出。所以一般要在 finally 块中写 unlock() 以防死锁。此外，ReentrantLoc 类提供了 2 种 竞争锁机制：公平锁和非公平锁。一般而言，非公平锁效率更高：公平锁需要维护线程队列顺序。

**性能上**
synchronized 是托管给 JVM 执行的，而 lock 是 java 写的控制锁的代码。从 java 1.6 开始，synchronized 可以有很多优化：有适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等，性能上也有很大提升。synchronized 采用的是 CPU 悲观锁机制，即线程获得的是独占锁；而 lock 采用的是乐观锁机制，其实现就是 CAS。研究 ReentrantLock 源码可以发现，其中一个比较重要的获得锁的方法是 compareAndsetState()，这里就是调用的 CPU 提供的特殊指令支持。

**用途上**
一般情况下，两者没有显著区别。而在特殊的复杂并发同步问题中，如以下情况，则更适合 ReentrantLoc：
* 某个线程在等待一个锁的控制权期间，需要中断；
* 需要分开处理一些 wait-notify，ReentrantLoc 里的 Condition 应用，能够控制 notify 特定线程；
* 具有公平锁功能，每个到来的线程都将排队等待。

{% asset_img synchronized-vs-lock.PNG synchronized vs lock %}
