---
title: java
date: 2018-06-03 15:15:38
categories: java
tags: [java, Q&A]
---
[toc]
# 关键字
一些关键字概况。

## transient
大多数容器类都实现了 Serializable 接口，这意味着，该类对象实例可以被序列化——只要实现了该接口，该类的所有属性和方法都会自动序列化，而不必关心具体序列化的过程。
然而在开发中常常会遇到类似这样的问题：这个类的有些属性字段需要序列化，但有些不需要甚至不应该被序列化，如用户敏感的账号密码银行卡等信息，这些信息并不希望在网络操作/本地序列化缓存中传输、保存，此时，使用 transient 关键字修饰，即可使得 **字段的生命周期仅存在于调用者的内存中而不会被序列化到磁盘或其他持久化位置中去**，即，被序列化的对象不会包含 transient 修饰的字段数据。

### 注意事项
* 只能修饰变量，而不能修饰方法和类。本地变量也不能被 transient 修饰，如果是用户自定义类变量，则该类需要实现 Serializable 接口；
* 一旦变量被 transient 修饰，将不再是对象持久化的一部分。静态变量不管是否被 transient 修饰，均不能被序列化。

_被 transient 修饰的变量真的不能被序列化吗？_
并不是：序列化的实现有两种途径：一是通过 Serializable 接口，此时所有的序列化都是自动进行的，使用 transient 可以排除不想序列化的部分；而另一种方式是实现 Externalizable 接口，此时所有的序列化动作都要在其 writeExternal() 方法中手动指定，即指定想要序列化的内容，这与该内容字段是否被 transient 修饰无关。


# 技术实现
一些语言技术实现。

## COW 优化策略
COW（Copy-On-Write，写时复制）是一种用于程序设计中的优化策略：一开始大家都在共享同一个内容，当某个人（线程）想要修改这个内容的时候，才会真正把内容拷贝并形成一个新的内容然后再修改。这是一种延时懒惰策略，主要应用于多并发场景。

### COW 容器
i.e. 写时复制容器。JDK1.5 引入了两个 COW 机制的实现类容器：CopyOnWriteArrayList、CopyOnWriteArraySet。简单理解就是：当需要往容器添加元素时，不直接往当前容器添加，而是将当前容器进行拷贝，复制出一个新的容器，然后将待添加元素加入到新的容器中，添加完成后，再将原容器的引用指向新容器。这样做的好处是，可以 **对容器进行并发读而不需要加锁**，因为当前容器不会添加容器，也就不会改变。整体上是一种读写分离的思想，读和写在不同的容器进行。
{% asset_img COW添加元素.png 添加元素 %}
整个 add 操作在锁保护下进行，避免多线程并发造成副本混乱：
```java
public boolean add(E e) {
    synchronized (lock) {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    }
```
由于所有的写操作都是在新数组进行，如果有并发写，则通过锁来控制；如果并发读，则：
* 如果写操作未完成，那么直接读取原数组的数据；
* 如果写操作已完成，但引用还未指向新数组，那么也是直接读取原数组的数据；
* 如果写操作已完成，并且引用已指向新数组，那么直接读取新数组的数据；
可见，读操作可以不加锁。

### 应用场景
适用于 **读多写少的并发场景**。比如白名单，黑名单，商品类目的访问和更新场景等。

### 问题和解决
* 内存占用：根据实现原理，当可变操作频繁发生时，会导致效率低下，也会造成内存占用过多的问题。实用场景，根据实际需要，初始化 COW 容器大小，减少扩容开销；使用批量添加，减少容器复制次数。
* 数据一致性问题：COW 只能保证数据的最终一致性，不能保证数据的实时一致性。如果希望写入的数据马上能读取到，此时不适合适用 COW 容器。


# 数据结构
Java 中实现的一些泛型数据结构。

## 跳表（SkipList）
### 从红黑树到跳表
目前常用的 key-value 数据结构有三种：Hash 表、红黑树、SkipList。各自优缺点（不考虑删除操作）：
* Hash表：插入、查找最快，为 O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。
* 红黑树：插入、查找为 O(logn)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。
* SkipList：插入、查找为 O(logn)，但常数项比红黑树要大；底层结构为链表，可无锁实现（CAS）；数据天然有序。

如果要实现一个 key-value 结构，需求的功能有插入、查找、迭代、修改，那么首先 Hash 表就不是很适合了：因为迭代的时间复杂度比较高；而红黑树的插入很可能会涉及多个结点的旋转、变色操作，因此需要在外层加锁，这无形中降低了它可能的并发度；而 SkipList 底层是用链表实现的，可以实现为 lock free，同时它还有着不错的性能（单线程下只比红黑树略慢），非常适合用来实现 key-value 结构。

JDK 中提供的基于红黑树的 TreeMap 保证内部元素有序，但非线程安全的，而且红黑树的实现中维持二叉树的平衡是个非常复杂的实现，并且（如果实现并发安全的话）并发环境下保持平衡的操作会使性能受到一定影响。
跳表（SkipList）是一种随机化的数据结构，是一种 **空间换取时间** 的算法：建立多级索引，以二分查找的方式遍历一个有序链表。

跳表所实现的功能和红黑树类似。基于排序的索引结构，其效率和红黑树相近，但实现难度和编程难度更简单，且在并发环境下表现良好（这也是选择它作为一些容器类的线程安全版本底层数据结构的原因）。相应地，以空间换时间本就意味着空间效率的降低，这种折中在数据结构实现中经常遇到。

### 数据结构
首先，从命名可见它是基于链表的数据结构，其次它又是一种多层次的链表结构。
[实现原理](https://blog.csdn.net/fjslovejhl/article/details/18941129 "跳表实现原理")
[实现原理](https://www.cnblogs.com/yangming1996/p/8084819.html "跳表实现原理")


### CAS 构建并发安全性



# 一些知识点

## 位操作

### 移位运算符
<<：  左移运算符，num << 1，相当于 num 乘以 2；
\>>： 右移运算符，num >> 1，相当于 num 除以 2；
\>>>：无符号右移，忽略符号位，空位都以 0 补齐。