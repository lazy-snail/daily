---
title: java
date: 2018-06-03 15:15:38
categories: java
tags: [java, Q&A]
---
[toc]
# 关键字
一些关键字概况。

## transient
大多数容器类都实现了 Serializable 接口，这意味着，该类对象实例可以被序列化——只要实现了该接口，该类的所有属性和方法都会自动序列化，而不必关心具体序列化的过程。
然而在开发中常常会遇到类似这样的问题：这个类的有些属性字段需要序列化，但有些不需要甚至不应该被序列化，如用户敏感的账号密码银行卡等信息，这些信息并不希望在网络操作/本地序列化缓存中传输、保存，此时，使用 transient 关键字修饰，即可使得 **字段的生命周期仅存在于调用者的内存中而不会被序列化到磁盘或其他持久化位置中去**，即，被序列化的对象不会包含 transient 修饰的字段数据。

### 注意事项
* 只能修饰变量，而不能修饰方法和类。本地变量也不能被 transient 修饰，如果是用户自定义类变量，则该类需要实现 Serializable 接口；
* 一旦变量被 transient 修饰，将不再是对象持久化的一部分。静态变量不管是否被 transient 修饰，均不能被序列化。

_被 transient 修饰的变量真的不能被序列化吗？_
并不是：序列化的实现有两种途径：一是通过 Serializable 接口，此时所有的序列化都是自动进行的，使用 transient 可以排除不想序列化的部分；而另一种方式是实现 Externalizable 接口，此时所有的序列化动作都要在其 writeExternal() 方法中手动指定，即指定想要序列化的内容，这与该内容字段是否被 transient 修饰无关。


# 技术实现
一些语言技术实现。

## COW 优化策略
COW（Copy-On-Write，写时复制）是一种用于程序设计中的优化策略：一开始大家都在共享同一个内容，当某个人（线程）想要修改这个内容的时候，才会真正把内容拷贝并形成一个新的内容然后再修改。这是一种延时懒惰策略，主要应用于多并发场景。

### COW 容器
i.e. 写时复制容器。JDK1.5 引入了两个 COW 机制的实现类容器：CopyOnWriteArrayList、CopyOnWriteArraySet。简单理解就是：当需要往容器添加元素时，不直接往当前容器添加，而是将当前容器进行拷贝，复制出一个新的容器，然后将待添加元素加入到新的容器中，添加完成后，再将原容器的引用指向新容器。这样做的好处是，可以 **对容器进行并发读而不需要加锁**，因为当前容器不会添加容器，也就不会改变。整体上是一种读写分离的思想，读和写在不同的容器进行。
{% asset_img COW添加元素.png 添加元素 %}
整个 add 操作在锁保护下进行，避免多线程并发造成副本混乱：
```java
public boolean add(E e) {
    synchronized (lock) {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    }
```
由于所有的写操作都是在新数组进行，如果有并发写，则通过锁来控制；如果并发读，则：
* 如果写操作未完成，那么直接读取原数组的数据；
* 如果写操作已完成，但引用还未指向新数组，那么也是直接读取原数组的数据；
* 如果写操作已完成，并且引用已指向新数组，那么直接读取新数组的数据；
可见，读操作可以不加锁。

### 应用场景
适用于 **读多写少的并发场景**。比如白名单，黑名单，商品类目的访问和更新场景等。

### 问题和解决
* 内存占用：根据实现原理，当可变操作频繁发生时，会导致效率低下，也会造成内存占用过多的问题。实用场景，根据实际需要，初始化 COW 容器大小，减少扩容开销；使用批量添加，减少容器复制次数。
* 数据一致性问题：COW 只能保证数据的最终一致性，不能保证数据的实时一致性。如果希望写入的数据马上能读取到，此时不适合适用 COW 容器。




