---
title: OS-线程
date: 2018-04-10 23:40:06
tags: [OS, 线程, 并发]
---
CPU 调度的基本单位是线程。
由线程 ID、程序计数器、寄存器集合、栈组成。与属于同一进程的其他线程共享代码段、数据段和其他 OS 资源，如打开的文件和信号等。

#### 多线程模型
有两种方法提供线程支持：用户层的 **用户线程**、内核层的 **内核线程**。
**多对一模型**
将多个用户级线程映射到一个内核线程，线程管理由线程库在用户空间进行，因而效率较高。但如果一个线程执行了阻塞系统调用，那么整个进程都会阻塞，而且因为任一时刻只有一个线程能访问内核，多个线程并不能并行运行在多处理器上，即并没有增加并发性。
**一对一模型**
将每个用户线程映射到一个内核线程。该模型在一个线程执行阻塞系统调用时，允许另一个线程继续执行，因而提供了比多对一更好的并发功能，也允许多个线程并行地运行在多处理器系统上。缺点是每创建一个用户线程就需要创建一个相应的内核线程。由于创建内核线程的开销会影响应用程序的性能，所以这种模型的绝大多数实现都限制了系统所支持的线程数量。
**多对多模型**
多路复用了许多用户线程到同样数量/更小数量的内核线程上。内核线程的数量可能与特定应用程序或特定机器有关。多对一没有增加并发性，一对一限制线程数量，多对多模型没有这两者的缺点：可以创建任意多的用户线程，并且相应内核线程能在多处理器上并发执行。
一个流行的多对多模型多路复用的同时，也允许将一个用户线程绑定到某个内核线程上。这个变种有时候被称为“二级模型”。

#### 线程库
为程序员提供创建和管理线程的 API。主要有两种方式来实现线程库：
1. 在用户空间中提供一个没有内核支持的库，此库的所有代码和数据结构都存在于用户空间中。调用库中的一个函数只是导致了用户空间的一个本地函数调用，而不是系统调用。
2. 执行一个有操作系统直接支持的内核级的库。此时，库的代码和数据结构存在于内核空间中。调用库中的一个 API 函数通常会导致对内核的系统调用。

目前使用的三种主要线程库是：
1. POSIX Pthread：作为 POSIX 标准的扩展，可以提供用户级或内核级的库。它是由 POSIX 标准（IEEE 1003.1c）为线程和同步定义的 API，这是线程的规范，而不是实现。
2. Win32：适用于 Windows OS 的内核级线程库。
3. Java 线程 API：允许线程在 Java 程序中直接创建和管理线程。然而，大多数 JVM 实例运行在宿主 OS 之上，Java 线程 API 通常采用宿主系统上的线程库来实现，即，在 UNIX 和 Linux 上，采用 Pthread 实现，在 Windows 上，采用 Win32 API 来实现。

同属一个进程的线程共享进程数据。不过，在有些情况下每个线程可能需要一定数据的自己的副本，这种数据成为线程特定数据。
