---
title: 线程
date: 2018-04-10 23:40:06
categories: OS
tags: [OS, 并发]
---
CPU 调度的基本单位是线程——比进程更轻量的调度执行单位。
由线程 ID、程序计数器、寄存器集合、栈组成。与属于同一进程的其他线程共享代码段、数据段、内存地址和其他 OS 资源，如打开的文件和信号等。线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源，又可以独立调度。

## 线程的实现及模型
主要有 3 种方式：使用内核线程实现、使用用户线程实现、使用用户线程+轻量级进程混合实现。

### 使用内核线程实现
内核线程（Kernel-Level Thread, KLT）就是直接由 OS Kernel 支持的线程，这种线程由内核来完成线程切换：内核通过操控调度器对线程进行调度，并负责讲线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样 OS 就有能力同时处理很多任务。支持多线程的内核就叫多线程内核（Multi-Threads Kernel）。
程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process，LWP），**轻量级进程就是通常意义上的线程**。由于每个轻量级进程都由一个内核线程支持（所以只有先支持内核线程，才能有轻量级进程），这种轻量级进程和内核线程之间 1:1 的关系，即将每个用户线程映射到一个内核线程（准确说是其高级接口：轻量级进程），称之为 **一对一线程模型**：
{% asset_img 一对一模型.png 一对一模型 %}
**优点**
* 该模型在一个线程执行阻塞系统调用时，允许另一个线程继续执行，因而提供了比多对一更好的并发功能，也允许多个线程并行地运行在多处理器系统上。

**缺点**
* 每创建一个用户线程就需要创建一个相应的内核线程，由于创建内核线程的开销会影响应用程序的性能，所以这种模型的绝大多数实现都限制了系统所支持的线程数量；
* 由于是基于内核线程实现，所以各种线程操作，如创建、析构及同步等，都需要进行系统调用，而系统调用的代价相对较高：需要在用户态和内核态来回切换。

### 使用用户线程实现
广义上，一个线程只要不是内核线程，就可以看作是用户线程（User Thread，UT）。从这个角度讲，LWP 也属于用户线程，但 LWP 的实现始终是建立在内核之上的，许多操作都要进行调用，效率因此受到限制；狭义上的 UT 指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、调度、销毁等完全在用户态种完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作快速且消耗较低，也可以支持大规模的线程数量。_部分高性能数据库种的多线程就是由用户线程实现的。_ 这种进程与用户线程之间 1:n 的关系称为 **一对多线程模型**，也称二级模型：
{% asset_img 一对多模型.png 一对多模型 %}
**优点&缺点**
* 该模型不需要系统内核支援（这也是劣势），也无须用户态到内核态的状态转换，效率更高；而所有的线程操作都需要用户程序自行处理，需要考虑各种问题。而且由于 OS 只把处理器资源分配到进程，诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来异常困难甚至不可能完成。并且如果一个线程执行了阻塞系统调用，那么整个进程都会阻塞，而且因为任一时刻只有一个线程能访问内核，多个线程并不能并行运行在多处理器上，即并没有增加并发性。

_实现的复杂度使得用户线程的使用越来越少，java、ruby 等曾经使用过用户线程，但后来也都放弃了。_

### 用户线程+轻量级进程混合实现
以上两种方法的混合实现：该模式即存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间，因此用户线程的创建、切换、析构等操作依然保持低消耗的优势，并且可以支持大规模的用户线程并发。而 OS 提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度能力和处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，大大降低了整个进程被完全阻塞的风险。该模式种用户线程和轻量级进程的数量不固定，即 n:m 的关系，称为 **多对多线程模型**：
{% asset_img 多对多模型.png 多对多模型 %}


## 线程库
为程序员提供创建和管理线程的 API。主要有两种方式来实现线程库：
1. 在用户空间中提供一个没有内核支持的库，此库的所有代码和数据结构都存在于用户空间中。调用库中的一个函数只是导致了用户空间的一个本地函数调用，而不是系统调用。
2. 执行一个有操作系统直接支持的内核级的库。此时，库的代码和数据结构存在于内核空间中。调用库中的一个 API 函数通常会导致对内核的系统调用。

目前使用的三种主要线程库是：
1. POSIX Pthread：作为 POSIX 标准的扩展，可以提供用户级或内核级的库。它是由 POSIX 标准（IEEE 1003.1c）为线程和同步定义的 API，这是线程的规范，而不是实现。
2. Win32：适用于 Windows OS 的内核级线程库。
3. Java 线程 API：允许线程在 Java 程序中直接创建和管理线程。然而，大多数 JVM 实例运行在宿主 OS 之上，Java 线程 API 通常采用宿主系统上的线程库来实现，即，在 UNIX 和 Linux 上，采用 Pthread 实现，在 Windows 上，采用 Win32 API 来实现。

同属一个进程的线程共享进程数据。不过，在有些情况下每个线程可能需要一定数据的自己的副本，这种数据成为线程特定数据。


## 并发与线程
并发不一定要依赖多线程（如 PHP 中常见的多进程并发），但 java 中的并发大多数与线程相关。