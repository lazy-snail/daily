---
title: IO
date: 2018-04-10 23:20:06
categories: OS
tags: [OS]
---
[toc]
I/O 是在主存和外部设备（磁盘、终端、网络等）之间复制数据的过程。

# 系统 I/O
说到 I/O，不免地先简要介绍一下文件相关的重要概念。

## 文件类型
Unix 里一切皆文件。
* 普通文件：文本文件、二进制文件对内核而言都是普通文件。
* 目录文件：包含了其他文件的名字和指向与这些文件有关信息的指针。只有内核可以直接写目录文件。
* 块特殊文件：提供对块设备（磁盘、缓存等）带缓冲的访问，每次访问固定长度的数据。
* 字符特殊文件：提供对设备不带缓冲的访问，每次访问长度可变。系统中所有的设备要么是字符特殊文件，要么是块特殊文件。
* FIFO：可用于进程间通信，也称命名管道。
* 套接字：用于进程间的网络通信。
* 符号链接：指向另一个文件。

## 文件描述符
对于内核而言，所有打开的文件都通过文件描述符引用，它是一个非负整数。UNIX 系统 shell 把文件描述符 0 与 标准输入关联，1 与标准输出关联，2 与标准错误关联。尽管这和内核无关，但各种 shell 和应用都遵循此惯例。

# I/O 模型
Linux 提供 5 种 I/O 模型，前 4 个是同步 I/O 模型：
* 阻塞式 I/O
* 非阻塞式 I/O
* I/O 复用
* 信号驱动 I/O（SIGIO）
* 异步 I/O

# I/O 多路复用
I/O 多路复用允许同时检查多个文件描述符，看其中是否有可以执行 I/O 操作的。基本思路就是使用 select、poll、epoll 等函数，要求内核挂起进程，只有在一个或多个 I/O 事件发生，才将控制返回给应用程序。可以在普通文件、终端、伪终端、管道、FIFO、套接字以及其他字符型设备上使用这些函数来检查文件描述符。它们允许进程一直等待（以阻塞的方式）文件描述符称为就绪态，或者调用时指定等待超时时间。

## select
以 select 为例，当我们对多个描述符感兴趣（想要进行操作）时，调用该函数，进入阻塞状态，在这些描述符中任一个准备好进行 I/O 时才返回，携带该描述符的信息，从而开始 I/O 操作。其中 select 的参数给内核的信息有：
* 调用者所关心的描述符列表；
* 对于每个描述符所关心的条件（读、写，以及是否关心该描述符的异常状态）；
* 等待时长（永久、定时、不等待）；

而 select 返回时，内核提供的信息有：
* 已准备好的描述符的数量；
* 对于读、写、异常这 3 个条件中的每一个，哪些描述符已经准备好。

### 过程
{% asset_img select调用过程.png select调用过程 %}
1. 使用 copy_from_user 从用户空间拷贝 fd_set 到内核空间
2. 注册回调函数 __pollwait
3. 遍历所有 fd，调用其对应的 poll 方法（对于 socket，这个 poll 方法是 sock_poll，sock_poll 根据情况会调用到 tcp_poll，udp_poll 或 datagram_poll）。以 tcp_poll 为例，其核心实现就是__pollwait，也就是上面注册的回调函数
4. __pollwait 的主要工作就是把 current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于 tcp_poll 来说，其等待队列是 sk->sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时 current 便被唤醒了。
5. poll 方法返回时会返回一个描述读写操作是否就绪的 mask 掩码，根据这个 mask 掩码给 fd_set 赋值。
6. 如果遍历完所有的 fd，还没有返回一个可读写的 mask 掩码，则会调用 schedule_timeout，使得调用 select 的进程（也就是 current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout 指定），还是没唤醒则调用 select 的进程会重新被唤醒获得 CPU，进而重新遍历 fd，判断有没有就绪的 fd
7. 把 fd_set 从内核空间拷贝到用户空间。

### 3 个缺点
* 每次调用 select 都需要把 fd_set(filedescriptor，即文件句柄集合)从用户态拷贝到内核态，这个开销在 fd 很多时会很大；
* 每次调用 select 都需要在内核遍历传递进来的所有 fd，这个开销在 fd 很多时也很大；
* select 支持的文件描述符数量太少，默认是 1024。

## poll
和 select 类似，主要区别在于如何指定待检查的文件描述符。select 中是提供 3 个集合，每个集合中标明感兴趣的文件描述符，而在 poll 中，提供一列文件描述符，并在每个文件描述符上标明感兴趣的事件。

## epoll
event poll，同样可以检查多个文件描述符上的 I/O 就绪状态。可以看作对 select 和 poll 的改进，Linux 专有。主要优点：
* 当检查大量文件描述符时，性能比 select、poll 高很多：无需多次向内核传递表示所有需要被检查的文件描述符所构成的数据结构，而是内核会为之记录需要检查的文件描述符有哪些；
* 既支持水平触发（LT），也支持边缘触发（ET），对应地，select、poll 只支持水平触发，信号驱动 I/O 只支持边缘触发；
etc

## LT ET
即 Level Trigger，水平触发；Edge Trigger，边缘触发。
* 水平触发：如果文件描述符上可以非阻塞地执行 I/O 系统调用，此时认为它已经就绪。
多路复用（如 select、poll）采用水平触发通知描述符就绪。水平触发可以在任意时刻检查文件描述符的就绪状态，这意味着当确定文件描述符处于就绪状态时，就可以对其执行一些 I/O 操作（也可以不执行），然后重复检查文件描述符状态，看其是否如仍然处于就绪状态。这也表明，我们无需在发现就绪状态的文件描述符上进行尽可能多的 I/O 操作，因为检查可以重复进行。
* 边缘触发：如果文件描述符自从上次状态检查以来有了新的 I/O 活动（如新的输入），此时需要触发通知。
信号驱动 I/O 采用边缘触发通知描述符就绪。只有当 I/O 事件发生时才收到内核通知，在另一个 I/O 事件到来之前不会有新的通知产生。另外，在通知到来时，我们通常并不知道需要处理多少 I/O（比如有多少字节可以读取），因此一般会尽可能多地处理：意即，一直执行 I/O 操作，直到相应的系统调用（read、write 等）以失败告终，此时证明该文件描述符上出现饥饿现象，不能再继续执行 I/O 操作。

参考：
https://cloud.tencent.com/developer/article/1005481
http://www.cnblogs.com/Anker/p/3265058.html
https://zhuanlan.zhihu.com/p/38277885