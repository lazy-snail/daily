---
title: 进程
date: 2018-04-10 23:20:06
categories: OS
tags: [OS, 并发]
---
程序本身并不是进程，进程是 **处于执行期的程序以及相关的资源的总称**。

**Linux 进程树**
Linux 和 Unix 类似，其进程之间存在明显的继承关系：所有的进程都是 PID 为 1 的 init 进程的后代。内核在系统启动的最后阶段启动 init 进程。
* 进程在创建它的时刻开始存活。在 Linux 系统中，这通常是调用 fork() 系统的结果，该系统调用通过复制一个现有进程来创建一个全新的进程。现代 Linux 内核中，fork() 实际上是由 clone() 系统调用实现的；
* fork() 系统调用结束时，从内核返回两次：一次回到父进程，在返回点这个位置上恢复执行；一次回到新产生的子进程，子进程开始执行；
* 接着调用 exec() 函数，创建新的地址空间，并把新的程序（可执行文件）载入其中；
* 最终，进程通过 exit() 系统调用退出执行，终结进程并释放所占用的资源。父进程可以通过 wait4() 系统调用查询子进程是否终结。进程退出执行后被设置为僵死状态，直到它的父进程调用 wait() 或 waitpid() 为止。

_进程的另一个名字是任务（task），Linux 内核通常也把进程叫做任务。_
**线程仅仅被视为一个与其它进程共享某些资源的进程。**

进程三种状态：
* **运行态**，该时刻进程实际占用CPU；
* **就绪态**，可运行，但因为其他进程正在运行而暂时停止；
* **阻塞态**，除非某外部事件发生，否则不能运行。

**进程间通信（Inter Process Communication，IPC）**
需要考虑的问题：
* 一个进程如何把信息传递给另一个；
* 如何确保两个/多个进程在关键活动中不会出现交叉；
* 信息传递的顺序问题。

两种模式：
1. 共享内存：建立一块供协作进程共享的内存区域，进程通过向此共享区域读/写数据来交换信息；
2. 消息传递：通过在协作进程间交换信息来实现通信。

消息传递对于交换较少数据量的数据很有用，因为不需要避免冲突，实现也比共享内存容易，通常需要系统调用来实现，因此需要更多的内核介入的时间消耗。共享内存允许以最快的速度（可以达到内存的速度）进行方便的通信，仅在建立共享内存区域时需要系统调用，一旦建立了共享内存，所有的访问都被处理为常规的内存访问，不需要来自内核的帮助，因而比消息传递快。

**同步问题**
临界区问题是设计一个以便进程协作的协议。
临界区问题的解答必须满足三个条件：
* **互斥（mutual exclusion）**：如果有一个进程在其临界区内执行，那么其他进程都不能在其临界区内执行；
* **前进（progress）**：如果没有进程在其临界区内执行，且有进程需要进入临界区，那么只有那些不在剩余区内执行的进程可参与选择，以确定下一个进入临界区的进程，且这种选择不能无限推迟；
* **有限等待（bounded waiting）**：从一个进程做出进入临界区的请求，直到该请求允许为止，其他进程允许进入其临界区的次数有上限。

临界区问题的解决都需要一个简单的工具——锁：从硬件到软件 API 实现，都需要实现锁的概念。
硬件方面，实现原子指令（需要特殊硬件支持）可以解决临界区问题。软件层面，使用信号量（semaphore）作为同步工具。信号量 S 是个证书变量，除初始化外，它只能通过两个标准原子操作：wait( )、signal( ) 来访问。这些操作原来成为 P （荷兰语 proberen，测试）和 V （荷兰语 verhogen，增加）。
信号量的主要缺点是都要求 **忙等待（busy waiting）**。当一个进程位于其临界区内时，任何其他试图进入其临界区的进程都必须在其进入代码中连续地循环。这种连续循环在实际多道程序系统中显然是个问题，因为这里只有一个处理器为多个进程所共享。忙等待浪费了 CPU 时钟，这本来可以有效地为其他进程所使用。这种类型的信号量也称为 **自旋锁**：进程在其等待锁时还在运行。而自旋锁的优点在于：进程在等待锁时不进行上下文切换，而这种切换可能会花费相当长的时间。因此，如果锁的占用时间短，自旋锁就很有用。多处理器系统中常用自旋锁，这样一个线程在一个处理器上自旋时，另一个线程可以在另一个处理器上进入其临界区。
克服忙等待的方式是修改信号量操作的定义，将一个进程执行 wait( ) 操作时，不进入忙等待，而是阻塞自己，从而将控制权转到 CPU 调度程序，以选择另一个进程来执行（需要上下文切换）。

**死锁和饥饿**
具有等待队列的信号量的实现可能导致这样的情况：两个/多个进程无限地等待一个事件，而该事件只能由这些等待进程之一来产生。这种状态下，这些进程就称为 **死锁（deadlocked）**。与之相关的另一个问题是 **无限期阻塞（indefinite blocking）** 或 **饥饿（starvation）**，即进程在信号量内无限期等待。

**管程（monitor）**
一种进程同步互斥工具，在功能上和信号量操作类似。当信号量不正确地用来解决临界区问题时，很容易产生死锁、破坏互斥等情况。管程作为处理这些错误的一种基本的、高级的同步语言构造被提出。
管程类型提供了一组由程序员定义的、在管程内互斥的操作，确保一次只有一个进程能在管程内活动。因此，不需要再显式编写同步代码。
