---
title: 进程
date: 2018-04-10 23:20:06
categories: OS
tags: [OS, 并发]
---
# 进程
程序本身并不是进程，进程是 **处于执行期的程序以及相关的资源的总称**。
进程的另一个名字是任务（task）。
Linux 内核通常也把进程叫做任务，线程仅仅被视为一个与其它进程共享某些资源的进程。

## 进程三种基础状态：
* **运行态**，该时刻进程实际占用CPU；
* **就绪态**，可运行，但因为其他进程正在运行而暂时停止；
* **阻塞态**，除非某外部事件发生，否则不能运行。
{% asset_img 三状态进程模型.PNG 进程状态转换 %}
此外，还有五状态进程模型、七状态进程模型：
{% asset_img 五状态进程模型.PNG 进程状态转换 %}
{% asset_img 七状态进程模型.PNG 进程状态转换 %}

## 进程控制块
Process Control Block，PCB


# 进程同步
进程间同步是指进程间的 **协作关系**。
进程同步，Synchronization，指系统中多个进程中发生的事件存在 **某种时序关系**，需要相互合作，共同完成一项任务。具体来说，一个进程运行到某一个点时，需要另一个进程为它提供消息，在未获得该消息之前，该进程进入阻塞状态，获得消息之后被唤醒进入就绪状态。
**进程互斥是一种特殊的进程同步关系**，即逐次使用互斥共享资源，也是对进程使用资源次序上的一种协调。
进程同步机制的实现方法主要有：信号量、管程、互斥、事件。

## 信号量
信号量能够实现互斥，提供同步功能。要求忙等待。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。

## 管程
在程序设计语言中引入的一种成分，作为一种高级同步原语，是语言概念。定义：
* 是一个特殊的模块
* 有一个名字
* 由关于共享资源的数据结构及在其上操作的一组过程组成
{% asset_img 管程结构.PNG 管程结构 %}

### 保证
* 互斥
管程有一个重要特性：**任一时刻管程中只有一个活跃进程**。这使得管程能有效完成互斥，保证管程中数据结构的数据完整性。其互斥性是由 **编译器** 负责保证的（管程本身是语言概念）。
* 同步
管程中设置 **条件变量及等待/唤醒操作** 来解决同步问题。让进程在条件变量上等待或者通过发送信号将等待在条件变量上的进程/线程唤醒。

### 与进程的关系
进程只能通过调用管程提供的各种过程，间接地使用管程中的数据结构。

## 互斥
进程间互斥是指进程间的 **竞争关系**。
进程间需要共享一些资源（变量、文件等），而这些资源需要 **排他性使用**，所以进程间对这些资源由竞争关系，这种竞争即称为“进程互斥”，这些被竞争的资源即称为临界资源/互斥资源/共享变量。在讨论进程互斥时，一般可以理解为这些进程间并不需要协作，即彼此无关，它们并不知道其它进程的存在，并且也不受其它进程执行的影响。

### 软件互斥方案
使用信号量（semaphore）作为同步工具。信号量 S 是个整数变量，除初始化外，它只能通过两个标准原子操作：wait()、signal() 来访问。这些操作原来成为 P （荷兰语 proberen，测试）和 V （荷兰语 verhogen，增加）。
信号量的主要缺点是都要求忙等待,忙等待浪费了 CPU 时钟，这本来可以有效地为其他进程所使用。这种类型的信号量也称为自旋锁。

### 硬件互斥方案：
使用硬件支持的特殊指令，来达到互斥的目的。
* 开/关中断
* 测试并加锁（Test and Set Lock, TSL)


# 进程间通信
见 IPC


# 相关概念

## 临界区
《现代操作系统》中对临界区的定义：对共享内存进行访问的程序片段（代码段），就是临界区。
进一步解释，当多个进程都要使用同一个共享资源时，它的代码里会有相应的操作，这些代码段就叫做临界区/互斥区。所谓临界区：是多个进程，对某一个临界资源实施操作的程序片段，也就是说这些程序片段分散在不同的进程中，它们的共同的特点，是对同一个临界资源进行一些操作。即这一段代码，和另外一个进程的这一段代码，他们互为临界区。
临界区问题是设计一个以便进程协作的协议。其解答必须满足三个条件：
* **互斥（mutual exclusion）**：如果有一个进程在其临界区内执行，那么其他进程都不能在其临界区内执行；
* **前进（progress）**：如果没有进程在其临界区内执行，且有进程需要进入临界区，那么只有那些不在剩余区内执行的进程可参与选择，以确定下一个进入临界区的进程，且这种选择不能无限推迟；
* **有限等待（bounded waiting）**：从一个进程做出进入临界区的请求，直到该请求允许为止，其他进程允许进入其临界区的次数有上限。

临界区问题的解决都需要一个简单的工具——锁：从硬件到软件 API 实现，都需要实现锁的概念。

## 忙等待 & 自旋锁
**忙等待（busy waiting）**，进程在得到临界区访问权之前，持续循环测试而不做其他事情，浪费了 CPU 资源，所以单核处理器时应避免忙等待。克服忙等待的方式是修改信号量操作的定义，将一个进程执行 wait() 操作时，不进入忙等待，而是阻塞自己，从而将控制权转到 CPU 调度程序，以选择另一个进程来执行（需要上下文切换）。
**自旋锁（spin lock）**，允许忙等待，进程在其等待锁时还在运行，这在多处理器中常用到。优点在于：进程在等待锁时不进行上下文切换，而这种切换可能会花费相当长的时间。因此，如果锁的占用时间短，自旋锁就很有用。多处理器系统中常用自旋锁，这样一个线程在一个处理器上自旋时，另一个线程可以在另一个处理器上进入其临界区。


https://www.cnblogs.com/youngforever/p/3250270.html