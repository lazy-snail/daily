---
title: 进程生命周期
date: 2018-04-10 23:20:06
categories: OS
tags: [OS, 进程]
---
# 创建进程
Linux 用户进程不能直接被创建出来，不存在这样的 API，而只能从某个进程中复制产生一个新的进程。这主要涉及到三个系统调用：fork 函数、vfork 函数、clone 函数。

## fork 函数
一个现有的进程可以调用 fork 函数创建一个新进程，新进程被称为子进程。fork 被调用一次，会返回两次：子进程返回值是 0，父进程返回值是新建子进程的 ID。子进程是父进程的副本，除了 ID 以外，子进程的各种数据结构（主要是正文段、数据段、堆、栈这 4 部分）都是父进程的拷贝副本。
fork() 的实际开销是复制父进程的页表和给子进程创建唯一的进程描述符（task_struct）。

### 写时复制
Copy-On-Write，COW。直接把父进程所有资源（也就是地址空间）全盘复制给子进程虽然简单，但效率低下，再考虑那些子进程可能很快甚至立即就执行（会修改数据）的情况，这种复制显得有些多余，所以引入了写时复制。即，只有进程空间各段的内容要发生变化（要写入）时，才会将父进程的内容复制一份给子进程，没有复制之前则处于和父进程共享同一个副本的状态。
写时复制的思想在 C++、java（一些线程安全的集合类）都有体现。

[参考](https://www.cnblogs.com/wuchanming/p/4495479.html)

## vfork 函数
vfork 函数的调用方式和返回值与 fork 相同，它的实现主要是为了优化那些创建好就立即调用 exec 函数而进入执行的进程的创建。它并不将父进程的地址空间复制到子进程中，而是共享父进程的地址空间。因为子进程会立即调用 exec 函数进入执行阶段，所以没有必要进行拷贝；另一个区别是，vfork 保证子进程先运行，即它会阻塞父进程，直到子进程退出或执行 exec()。
引入 COW 技术之后，fork 函数的开销也降低了很多，vfork() 的意义也不是特别明显了。甚至有的实现直接是调用 fork() 完成的。

## clone 函数
clone() 主要用于线程的创建，为用户线程提供了良好的支持。这个接口提供了更多的灵活性，可以让用户指定父进程和子进程（也就是创建的进程）共享的内容。其实通过传递不同的参数，clone() 可以实现 fork() 和 vfork() 的功能。

# 运行
子进程创建完毕之后，往往要调用 exec() 来执行一个程序（父进程、子进程都有可能）。exec 是一个函数族，包括 execl、execlp、execle、execv、execve、execvp 6 个具体实现，区别在于对路径名、参数以及环境变量的指定上。

[参考](https://blog.csdn.net/yangbodong22011/article/details/50197785)