---
title: 锁
date: 2018-04-09 17:03:14
categories: DB
tags: [DB, MySQL]
---
[toc]


# 锁
锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并发访问，提供数据的 **完整性和一致性**。
多用户、数据库驱动的应用中，很大的一个难点是：一方面要最大程度地利用数据库的并发访问，一方面要确保每个用户能以一致的方式读取和修改数据。为此有了锁（locking）机制。

**不同数据库的锁实现机制一般不同**
MySQL 中，MyISAM 引擎使用表锁，并发读没有问题，但并发插入的性能就要差很多了。InnoDB 引擎提供一致性的非锁定读、行级锁支持。行级锁没有相关额外的开销，并可以同时得到并发性和一致性。

## MySQL 锁
MySQL 中共有 4 种锁。
* 表锁
* 页锁
* 行锁（少数独立存储引擎才有，如 InnoDB）
* 元数据锁：5.5 版本加入的新特性。仅对表中的元数据启用，当有线程开始使用表时，元数据锁就会锁住表的所有元数据。

**元数据**
DDL 语句的更改信息，如 CREATE、DROP、ALTER 等修改方案的语句。老版本中引入元数据是为了解决线程可以在其他线程中的并发事务使用相同表的情况下修改表定义或是删除表的问题。

## latch 和 lock
这是锁中容易混淆的两个概念。两者都可以称为“锁”。
* latch 一般称为闩锁（轻量级的锁），对象是线程，因为其要求锁定的时间必须非常短，若持续时间长，则应用的性能会非常差，InnoDB 中，latch 又分为 mutex（互斥量）和 rwlock （读写锁）。目的是用来保证并发线程操作临界资源的正确性，通常没有死锁检测的机制；
* lock 的对象是事务，用来锁定的是数据库中的对象，如表、页、行等，一般 lock 的对象仅在事务 commit/rollback 后进行释放（不同事务隔离级别释放的时间可能不同），有死锁检测机制。
{% asset_img lock与latch对比.PNG lock vs latch %}

# InnoDB 中的锁类型
## 标准行级锁
InnoDB 提供两种标准的行级锁：
* **共享锁（S Lock）**：允许事务读一行数据；
* **排他锁（X Lock）**：允许事务删除或更新一行数据；

**锁兼容（Lock Compatible）**：如果一个事务 T1 已经获得了行 r 的共享锁，那么另外的事务 T2 可以立即获得行 r 的共享锁，因为读取并不会改变行 r 的数据，这种情况就是锁兼容。S 和 X 都是行锁，兼容是指对同一行记录（row）锁的兼容性情况。

### 行级锁优缺点
InnoDB 行锁效率很高，占用内存也很少，但细粒度的行锁在锁定的时候仍然会带来额外开销，比表锁、页锁消耗的内存要多；细粒度意味着锁的请求数量可能较多，而较多的锁会占用资源，降低性能；在执行对大部分数据的 GROUP BY 操作或频繁扫描很多数据时，性能会明显下降。

## 意向锁（表级）
InnoDB 支持多粒度（granular）锁定，允许 **事务在行级上的锁和表级上的锁同时存在**。为此，InnoDB 支持一种额外的 **表级别锁**——意向锁。可以理解为意向锁将锁定的对象分为多个层次，意味着事务希望在更细粒度（fine granularity）上进行加锁，先要在粗粒度上加相应的意向锁，以表明在接下来的动作想要获取该记录的锁。
如果将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，则首先需要对粗粒度的对象上锁。如，对页上的记录 r 上 X 锁，那么分别要对数据库A、对应表、对应页上意向锁 IX，最后对记录 r 上 X 锁。如果其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成才能继续。
{% asset_img 层次结构.PNG 层次结构 %}
意向锁作为表级锁，其设计目的是为了在一个事务中揭示下一行将被请求的锁类型。意向锁的枷锁过程是自动的，无需用户干预。
InnoDB 支持两种意向锁：
* **意向共享锁（IS Lock）**：事务想要获得一张表中某几行的共享锁；
* **意向排他锁（IX Lock）**：事务想要获得一张表中某几行的排他锁。

由于 InnoDB 支持的是行级别的锁，因此意向锁不会阻塞除全表扫描以外的任何请求。锁的兼容性如下：
{% asset_img InnoDB锁兼容性.PNG InnoDB 锁的兼容性 %}

## 一致性非锁定读（Consistent Nonlocking Read）
指 InnoDB 通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行 DELETE 或 UPDATE 操作，这时读取操作不会因此去等待行上的锁释放。而是，InnoDB 会去读取该行的一个快照数据：
{% asset_img 一致性非锁定读.PNG 一致性非锁定读 %}
之所以称之为非锁定读，因为不需要等待访问的行上 X 锁的释放。
快照数据是指该行的之前版本的数据，一个行记录可能有不止一个快照数据，该实现是通过 undo 段来完成，而 undo 用来在事务中回滚数据，因此快照数据本身没有额外开销。此外，读取快照数据不需要上锁，因为没有事务需要对历史数据进行修改操作。
非锁定读机制极大提高了数据库的并发性，这是 InnoDB 默认设置下的读取方式。但在不同事务隔离级别下，读取的方式不同：
* **READ COMMITTED**：总是读取行的最新版本，锁定则读最新快照版本；
* **REPEATABLE**：总是读取事务开始时的行数据。

## 一致性锁定读
对于增删改语句，InnoDB 会自动给涉及的数据集加排他锁，而对普通的 SELECT 语句则不会加任何锁。某些情况下如典型的事务、存储过程等，用户需要显式地对数据库读取操作加锁，以保证数据逻辑的一致性。InnoDB 对于 SELECT 语句支持两种一致性的锁定读（Locking Read）操作：
* **SELECT...FOR UPDATE**：对读取的行记录加一个 X 锁，
* **SELECT...LOCK IN SHARE MODE**：对读取的行记录加一个 S 锁。

上述语句必须在一个事务中，当事务提交了，锁也就释放了。因此要加上  BEGIN，START TRANSACTION 或 SET AUTOCOMMIT=0。

## 外键和锁
InnoDB 中，如果外键列没有显式添加索引，则自动对其添加一个索引，以避免表锁。

# 锁算法
InnoDB 由 3 种行锁算法：
* **Record Lock**：单个行记录上的锁，总是锁住索引记录，如果表上没有索引，则使用隐式的主键进行锁定；
* **Gap Lock**：间隙锁，锁定一个范围，但不包含记录本身；
* **Next-Key Lock**：Record Lock + Gap Lock，锁定一个范围，并锁定记录本身。能够解决幻读问题。当查询的索引含有唯一属性时，InnoDB 会将其优化降级为 Record Lock，即仅锁住索引本身而不再是范围。

## Next-Key 锁
当我们用范围条件（而非相等条件）检索数据并请求锁时，InnoDB 会给符合条件的已有数据记录项加锁，对于键值在条件范围内但并不存在的记录，叫做“间隙（Gap）”，InnoDB 也会对这个间隙加锁，这就是所谓的 Next-Key 锁机制。
如，emp 表有 101 条记录，其 empid 值分别为 1、2、3...101，则以下语句：
```sql
SELECT * FROM emp WHERE empid > 100 FOR UPDATE;
```
这条查询语句就是范围检索，InnoDB 不仅会对符合条件的 empid 记录，这里只有 101 一行加锁，也会对 empid > 100 的“间隙”加锁，尽管并不存在这样的数据，但考虑这样一个场景，如果其他事务试图插入 empid > 100 的数据，此时就不会成功，因为该范围被锁定，插入操作会失败。而如果不采取该锁机制，则插入有可能会成功，就会出现幻读现象。
显然，这种锁机制会阻塞符合条件查询内键值的并发插入，这往往造成严重的锁等待和性能问题，因此，在并发场景下，应该考虑优化业务逻辑，尽量使用相等条件进行检索，避免范围检索。但要注意一个问题：如果使用相等条件查询，而查询结果不存在这样的记录，那么 InnoDB 会使用 Next-Key 锁，这就意味着，几乎将全部的范围都锁定了。

_事务隔离级别为 READ COMMITTED 时，仅采用 Record Lock_。

# 锁导致的问题
因为事务隔离性的要求，锁只会带来三种问题：
* 脏读
* 不可重复读
* 丢失更新

## 阻塞
指由于不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源。阻塞并不是一件坏事，是为了确保事务可以并发且正常执行。超时会跑出1205错误。调整参数↓
innodb_lock_wait_timeout：设置等待时间（默认50秒），可动态调整；
innodb_rollback_on_timeout：设置是否在等待超时时对进行中的事务进行回滚操作（默认OFF，不回滚），静态的，不可在启动时修改。

## 死锁
解决死锁最简单的方式是不要有等待，将任何的等待都转化为回滚，并且重新开始事务。然而这将导致并发性能的下降甚至所有的事务都无法进行。
另一种解决方法是超时，即当事务相互等待时，当其中一个事务等待时间超过设置的阈值，进行回滚操作，这时其它事务就有可能继续执行。InnoDB中超时设置参数：innodb_lock_wait_timeout（默认50秒）。
超时机制虽然简单，但若超时的事务所占权重较大，如操作更新了很多行，占用了较多的 undo log，此时回滚该事务的时间相比于其它事务所占用的时间可能更多。因此除了超时机制外，当前数据库普遍采用 wait_for graph（等待图）的方式来进行死锁检测。较之超时的解决方案，这是一种更为主动的死锁检测方式。等待图要求数据库保存以下两种信息：
* 锁的信息链表；
* 事务等待链表；

通过上述链表构造出一张图，如果这个图中存在回路，就代表存在死锁，此时 InnoDB 选择一个 undo 量最小的事务进行回滚，并报告一个立即可见的错误，如果不能解除死锁，则继续选择回滚，直到死锁解除。
等待图的死锁检测通常采用深度优先的非递归算法实现（1.2.x版本之后，之前采用递归的深度优先算法实现）。

## 乐观锁 vs 悲观锁
互斥同步、非互斥同步，并发控制技术手段上的概念。
**乐观锁（Optimistic Lock）**
假设数据一般情况下不会发生并发冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。如果冲突，则返回错误，让用户决定如何去做，这意味着乐观锁不能解决脏读问题，其实现算是一种 CAS 操作。其实现：
* 使用数据版本记录机制实现。为数据增加一个版本标识，如“version”，每更新一次数据，则对标识进行一次累加操作。
* 时间戳（timestamp）记录机制：在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果不一致则冲突。

适用于多读少写的场景，可以提高吞吐率。

**悲观锁（Pessimistic Lock）**
假定数据会发生并发冲突，从而以预防冲突的方式屏蔽可能违反数据完整性的冲突操作。简言之就是每次读写数据都认为会被其他线程修改，所以都需要先上锁。java synchronized 就属于悲观锁的一种实现。
