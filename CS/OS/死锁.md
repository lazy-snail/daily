---
title: 死锁
date: 2018-04-20 22:45:52
categories: OS
tags: OS
---
**资源的申请和释放**
OS 的各种资源如 CPU、内存空间、文件、I/O 设备等，都是有限的。进程在使用资源之前必须申请，使用之后必须释放。资源的申请与释放属于系统调用嗯。即，正常情况下的顺序是：
1. 申请。如果申请不能立即被允许（如，所申请资源正在被其他进程所占用），那么申请进程必须等待，直到获取该资源；
2. 使用。进程对资源进行操作（如，在打印机上打印一份文档）；
3. 释放。进程将占用的资源释放。

#### 定义
当一组进程中的每个进程都在等待一个事件，而这一事件只能由这组进程中的某一个进程引起，那么这组进程就处于死锁状态。

#### 产生死锁的必要条件
同时满足以下 4 个条件，才会产生死锁：
* **互斥**：至少有一个资源必须处于非共享模式，即一次只有一个进程使用。如果另一进程申请该资源，那么申请进程必须等到该资源被释放；
* **占有并等待**：一个进程必须占有至少一个资源，并等待另一资源，而该资源为其他进程所占有；
* **非抢占/不可剥夺**：资源不能被抢占，即资源只能在进程完成/结束任务后自动释放；
* **循环等待**：一组等待进程造成资源上的循环等待。

这些条件并不完全独立，比如循环等待条件就意味着占有并等待条件已经发生。

#### 处理方法
从原理上讲，有 3 种解决死锁的方法：
* 使用协议以预防/避免死锁，确保系统不会进入死锁状态；
* 允许系统进入死锁状态，然后检测，并加以恢复；
* 忽视这个问题，认为死锁不可能在系统内发生。

绝大多数 OS 采用第三种方法，包括 UNIX 和 Windows。即，应用程序开发人员要自行处理死锁问题。


**死锁预防**
从出现死锁的 4 个必要条件可知，只要确保至少一个条件不成立，就能预防死锁发生：
1. 互斥：对于非共享资源，必须要有互斥条件。共享资源，如只读文件，不需要互斥访问；
2. 占有并等待：当一个进程申请一个资源时，它不能占有其他资源。一种方式是每个进程在执行前申请并获得所有资源；另一种是允许进程在没有资源时才可申请，而在申请更多资源之前，必须释放已分配的所有资源；
3. 非抢占：可以使用这样的协议破坏非抢占：如果一个进程占有资源并申请另一个不能被立即分配的资源，那么其现有已分配的资源都可以被抢占，即这些资源都被隐式地释放了；
4. 循环等待：资源排序？不可行。要从应用程序设计角度解决循环等待问题。

**死锁避免**
死锁预防的方法限制了资源的申请方式，副作用是低设备使用率和系统吞吐率。
另一种方式：通过计算可用资源与进程所需资源来决定当前申请是否能够给予满足或必须等待，从而避免死锁发生。：
* 银行家算法
* 资源分配图算法
* 安全状态

**死锁检测**

**死锁恢复**
* 终止进程：一次终止一个进程直到死锁解除；一次性终止所有死锁进程；
* 抢占资源：问题有 如何选择牺牲品，即抢占哪个进程的资源；回滚，被抢占的进程如何处理；饥饿，如何确保不会发生饥饿（某一进程总是被选为牺牲品）。
