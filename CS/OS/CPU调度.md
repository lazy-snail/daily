---
title: CPU调度
date: 2018-04-20 07:40:12
categories: OS
tags: OS
---
CPU 调度的基本单位是线程。
对于单处理器系统，每次只允许一个进程运行，任何其他进程必须等待，直到 CPU 空闲能被调度。**多道程序** 的目标是在任何时候都有某些进程在运行，以最大化利用 CPU：多个进程同时处于内存中，当前正在执行的进程遇到必须等待的情况，如等待 I/O 请求完成时，OS 从该进程拿走 CPU 的使用权，交由其他进程继续执行。即，CPU 调度。
几乎所有的计算机资源在使用前都需要调度，而 CPU 是最重要的资源之一。所以 CPU 调度设计很重要。

#### 抢占调度
CPU 调度决策在4种环境下发生：
1. 当一个进程从运行状态切换到等待状态（如，I/O 请求，调用 wait( ) 等待一个子进程的终止）
2. 当一个进程从运行状态切换到就绪状态（如，出现中断）
3. 当一个进程从等待状态切换到就绪状态（如，I/O 完成）
4. 当一个进程终止时。

对于情况 1 和 4，只能直接调度。而对于情况 2 和 3，可以进行选择。当调度只能发生在情况 1 和 4 时，称调度方案是 **非抢占的（nonpreemptive）** 或 **协作的（cooperative）**，否则，称为 **抢占的（preemptive）**。
非抢占调度中，一旦 CPU 分配给一个进程，那么该进程会一直使用 CPU 直到进程终止或切换到等待状态。但，抢占调度对访问共享数据是有代价的：考虑两个进程共享数据的情况，第一个进程正在更新数据时，它被抢占以使得第二个进程能够运行，此时可能试图读共享区域的数据，那么该数据就处在不一致的状态。这时需要 **同步机制** 来协调：OS 随时都能接受中断，所以受中断影响的代码段必须加以保护以避免同时访问。

#### 调度算法
* **先到先服务（First Come， First Served）**
最简单的调度算法，可以用 FIFO 队列来实现。这是一种非抢占式的调度算法，考虑到无法均衡 CPU 密集型和 I/O 密集型任务，该方法平均性能并不理想。

* **最短作业优先（Shortest-Job First）**
SJF 调度算法可证明为最佳，因为给定一组进程，该算法平均等待时间最小。但其困难在于，如何知道下一个 CPU 区间的长度，即，如何确定哪个进程是”最短作业”。所以近似做法是，用数学方式预测下一个 CPU 区间长度。

* **优先级调度**
SJF 也可以算作优先级调度算法的一个特例：预测的 CPU 区间越大，优先级越小。优先级通常为固定区间的数字，但对于数字大小和优先级的对应（更小的数代表更高还是更低的优先级），各种系统的具体实现并不相同。
优先级调度可以是抢占的也可以是非抢占的：新到达进程优先级高于当前进程，抢占式调度会抢占 CPU，非抢占式调度只将新进程加到就绪队列的头部。
主要问题是 **无穷阻塞/饥饿**，可以运行但缺乏 CPU 的进程可以认为是阻塞的，优先级调度可能会使某个低优先级进程无穷等待 CPU。_据说，在 1973 年关闭 MIT 的 IBM 7094 时，发现有一个低优先级进程是于 1967 年提交但一直未运行。_
解决方案之一是老化技术（aging）：随着等待时间的加长，增加等待进程的优先级。

* **轮转法（Round-Robin）**
专门为分时系统设计的。类似于 FCFS 调度，但增加了抢占以切换进程。定义一个较小的时间单元（时间片），通常为 10-100 ms，将就绪进程队列作为循环队列，为每个进程分配不超过一个时间片的 CPU。等待时间可能较长。
问题是选择合适的时间片大小：过大就和 FCFS 算法一样，过小会导致频繁切换进程，导致系统调用上下文切换所浪费的时间开销过大。

* **多级队列（Multilevel Queue Scheduling Algorithm）**
如果进程可以很容易地分组情况下，如划分为前台（交互）进程和后台（批处理）进程，可以建立另一种调度算法。
对每个分组采用不同的调度算法，如前台进程队列采用 RR 调度，后台队列采用 FCFS 调度等。此外，队列之间也必须有调度，通常采用固定优先级抢占调度：显然前台进程队列需要更高的优先级。
进一步，**多级反馈队列调度算法（Multilevel Feedback Queue Scheduling Algorithm）**，允许进程在队列之间移动：如果进程使用过多 CPU 时间，会被转移到更低优先级队列；而较低优先级队列中等待时间过长的进程会被转移到更高优先级队列，以这种形式的老化来防止饥饿的发生。

#### 多处理器的调度
* **非对称多处理（Asymmetric Multiprocessing）**
让一个处理器（主服务器）处理所有的调度决定、I/O 处理和其他系统活动，其他处理器只执行用户代码。这种方法比较简单：只有一个处理器访问系统数据结构，减轻了数据共享的需要。

* **对称多处理（Symmetric Multiprocessing，SMP）**
每个处理器自我调度。所有进程处于一个共同的就绪队列中，或每个处理器有它自己的私有就绪进程队列。但要保证两个处理器不能选择同一个进程，且进程不会从队列中丢失。

**处理器亲和性**
进程从一个处理器中断，再次执行时被转移到其他处理器的话：被迁移的第一个处理器缓存中的内容必须置为无效，而将要迁移到的第二个处理器的缓存需要重建。由于使缓存无效或重新构建的代价很高，大多数 SMP 试图避免在处理器间迁移进程，而是尽可能保证使一个进程在同一个处理器上运行，称之为处理器亲和性，即一个进程需要有一种对其所在处理器的亲和性。
如Linux，提供一个支持硬亲和性（hard affinity）的系统调用，从而允许进程指定它不允许迁移到其他处理器上。如果 OS 无法保证这一点，就会出现软亲和性（soft affinity），这时进程可能会在处理器间移动。

**负载平衡（Load Balancing）**
SMP 系统中，保持所有处理器工作负载平衡很重要。通常这一概念只是针对拥有自己私有可执行进程队列的处理器而言的。在具有共同队列的系统中，通常不需要负载平衡，因为一旦某个处理器完成了一个进程，它就会立即从队列中取下一个进程继续执行。
