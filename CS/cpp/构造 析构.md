---
title: 构造 析构
date: 2018-05-22 16:20:41
categories: cpp
tags: cpp
---
# 构造函数
## 默认生成
默认情况下，编译器会为一个类自动生成：
* 一个默认构造函数：X();
* 一个拷贝构造函数：X(const X&);
* 一个拷贝赋值运算符：X& operator=(const X&);
* 一个移动构造函数：X(X&&);
* 一个移动赋值运算符：X& operator=(X&&);
* 一个析构函数：~X();

如果用户定义了其中一个/多个构造函数，则：
* 如果声明了任意构造函数，则不再生成默认构造函数；
* 如果声明了拷贝操作、移动操作或析构函数，则不再生成相应的拷贝操作、移动操作或析构函数。
可以使用显式声明默认操作（=default）。

## 成员初始化顺序
构造函数中的参数列表顺序并不代表类中成员变量的初始化顺序，成员的初始化顺序取决于成员在类中声明/定义的顺序。

## 初始化 赋值
首先，**类成员的初始化总是在构造函数之前执行**。
构造函数可以通过初始化列表或传参（也就是用参数给类成员赋值）两种方式初始化类实例。如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前进行默认初始化。二者存在一些差别，具体到内置数据类型和自定义数据类型来考虑：
* 内置数据类型/复合类型（指针、引用）：使用成员初始化列表和在构造函数体内赋值，二者的性能和结果上都是一样的；
* 用户自定义类型（类类型）：结果上还是一样的。但性能上有差异，类类型的数据成员对象在进入函数体前就已经构造完成，也就是说在成员初始化列表处进行构造对象的工作（仅此一次调用构造函数），然后通过拷贝赋值方式初始化数据成员；而构造函数赋值则是在进入构造函数体后，先将数据成员初始化为空值，然后以“=”赋值的方式进行数据成员的赋值工作，这会导致两次调用构造函数：初始化对象一次，给数据成员赋值时一次。
另外，一些情况下，只能使用初始化方式：
* 成员是类或结构，且构造函数带参数。成员初始化时无法调用缺省（无参）构造函数；
* 成员是常量或引用。成员无法赋值，只能被初始化。

## 委托构造函数
C++11 扩展了构造函数初始值的功能，可以定义使用委托构造函数（delegating constructor）：使用类的其他构造函数执行自身初始化过程的构造函数：把自身的一部分/全部初始化工作委托给其他构造函数来执行。

## 类不变式
构造函数的任务是初始化该类的一个对象，初始化操作必须建立一个 **类不变式（class invariant）**，即当成员函数（从类外）被调用时必须保持的某些东西。例，vector 的含初始化容量（int size）的构造函数必须保证至少两点：能够保存 size 个对象；size 非负，所以构造函数要确保传入的 size 非负，并且申请相应的资源，在执行中如果出错（size 为负数或申请空间失败），必须通告异常。



# 析构函数
如果 class 没有定义析构函数，那么只有在 **class 的成员对象或父类拥有析构函数** 的情况下，编译器才会自动合成一个析构函数。否则，被视为不需要析构函数从而不被合成。

## 虚析构函数
用来做基类的类的析构函数一般都是虚函数，是为了 **当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用**。