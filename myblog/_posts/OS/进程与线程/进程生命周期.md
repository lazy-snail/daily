---
title: 进程生命周期
date: 2018-04-10 23:20:06
categories: OS
tags: [OS, 进程]
---
# 创建进程
Linux 用户进程不能直接被创建出来，不存在这样的 API，而只能从某个进程中复制产生一个新的进程。这主要涉及到三个系统调用：fork 函数、vfork 函数、clone 函数。

## fork 函数
一个现有的进程可以调用 fork 函数创建一个新进程，新进程被称为子进程。fork 被调用一次，会返回两次：子进程返回值是 0（因为进程 ID 都大于 0，返回 0 是为了提供程序在该子进程中执行），父进程返回值是新建子进程的 ID。子进程是父进程的副本，除了 ID 以外，子进程的各种数据结构（主要是正文段、数据段、堆、栈这 4 部分）都是父进程的拷贝副本。
fork() 的实际开销是复制父进程的页表和给子进程创建唯一的进程描述符（task_struct）。

### 写时复制
Copy-On-Write，COW。直接把父进程所有资源（也就是地址空间）全盘复制给子进程虽然简单，但效率低下，再考虑那些子进程可能很快甚至立即就执行（会修改数据）的情况，这种复制显得有些多余，所以引入了写时复制。即，只有进程空间各段的内容要发生变化（要写入）时，才会将父进程的内容复制一份给子进程，没有复制之前则处于和父进程共享同一个副本的状态。
写时复制的思想在 C++、java（一些线程安全的集合类）都有体现。

[参考](https://www.cnblogs.com/wuchanming/p/4495479.html)

## vfork 函数
vfork 函数的调用方式和返回值与 fork 相同，它的实现主要是为了优化那些创建好就立即调用 exec 函数而进入执行的进程的创建。它并不将父进程的地址空间复制到子进程中，而是共享父进程的地址空间。因为子进程会立即调用 exec 函数进入执行阶段，所以没有必要进行拷贝；另一个区别是，vfork 保证子进程先运行，即它会阻塞父进程，直到子进程退出或执行 exec()。
引入 COW 技术之后，fork 函数的开销也降低了很多，vfork() 的意义也不是特别明显了。甚至有的实现直接是调用 fork() 完成的。

## clone 函数
clone() 主要用于线程的创建，为用户线程提供了良好的支持。这个接口提供了更多的灵活性，可以让用户指定父进程和子进程（也就是创建的进程）共享的内容。其实通过传递不同的参数，clone() 可以实现 fork() 和 vfork() 的功能。

# 运行
子进程创建完毕之后，往往要调用 exec() 来执行一个程序（父进程、子进程都有可能）。exec 是一个函数族，包括 execl、execlp、execle、execv、execve、execvp 6 个具体实现，区别在于对路径名、参数以及环境变量的指定上。

[参考](https://blog.csdn.net/yangbodong22011/article/details/50197785)

# 终止进程
8 种方式使进程终止（termination），
5 种正常终止：
* 从 main 返回
* 调用 exit
* 调用 _exit 或 _Exit
* 最后一个线程从其启动例程返回
* 从最后一个线程调用 pthread_exit
3 种异常终止：
* 调用 abort
* 接收到一个信号
* 最后一个线程对取消请求做出响应

## wait waitpid
当一个进程终止（正常或异常）时，内核就会向其父进程发送 SIGCHLD 信号。因为子进程的终止是个异步事件（可以在父进程运行的任何时候发生），所以该信号也是内核向父进程发送的异步通知。父进程可以选择忽略该信号（系统默认动作就是忽略），或者提供一个该信号发生时即被调用的函数（信号处理函数）。而可提供的信号处理函数中，就有 wait/waitpid。调用它们将：
* 如果所有子进程都还在运行，则阻塞；
* 如果一个子进程已经终止，正等待父进程获取其终止状态，则取得该子进程的终止状态并立即返回；
* 如果它没有任何子进程，则立即报错并返回。
具体即，如果子进程处于僵死状态，则 wait 立即取得该子进程的状态并返回，否则 wait 使其调用者阻塞，直到有一个子进程终止。如果调用者阻塞而且它有多个子进程，则在其某个子进程终止时，wait 立即返回，返回信息中就包含子进程的 ID 等信息，所以调用者了解是哪个子进程终止了。

两个函数的区别，主要在于是否阻塞调用者：
* 在一个子进程终止前，wait 使其调用者（该子进程的父进程）阻塞，而 waitpid 有一个选项可以使调用者不被阻塞；
* waitpid 并不等待在其被调用之后的第一个终止子进程，它有若干选项，可以控制所等待的进程。

**waitid**
和 waitpid 类似，waitid 允许一个进程指定要等待的子进程，但它使用两个单独的参数表示要等待的子进程所属的类型。

**wait3 wait4**
大多数 UNIX 系统提供这两个函数，使用附加参数，使得功能上比上述 wait 函数多一个：允许内核返回由终止进程及其所有字进程使用的资源概况，包括用户/系统 CPU 使用时间总量、缺页次数、接收到信号的次数等。

## 僵尸进程
（APUE：Unix 术语中）僵尸进程是指：一个已经终止、但是其父进程尚未对其进行善后处理（获取该终止子进程的有关信息，释放终止状态占用的资源）的进程。
进程退出时，内核会释放该子进程所使用的存储区、关闭其打开的文件以及其他清理工作。同时内核为每个终止的进程仍然保留了一定量的信息，如进程 ID、终止状态、使用的总 CPU 时间等，父进程通过调用 wait()/waitpid() 可以获取这些信息，直到此时（父进程完成 wait/waitpid 调用），这些额外保留的信息才会被释放。如果一个长期进程在执行中 fork 了很多子进程，那么除非父进程等待获取子进程的状态，否则这些子进程终止后都会变成僵死进程。
考虑这样的场景：如果父进程一直不调用 wait/waitpid，那么终止进程保留的信息就会一直占据一些资源，包括有限的进程号。在僵尸进程数量过大的情况下，就有可能导致系统无法再分配资源给新建进程，危害系统安全。

### 避免
有两个相关信号 SIGCLD、SIGCHLD，它们的来源不同（SIGCLD 来自 System V，而 SIGCHLD 来自 BSD 和 POSIX.1），处理方式也不同：
* BSD SIGCHLD 的语义：当该信号发生时，说明子进程的状态发生了改变，这时需要调用 wait 函数确认状态的变化。
* System V 的 SIGCLD 信号处理方式为：
> 如果进程设置信号 SIGCLD 的处理动作为 SIG_DFL，即默认的处理方式，不理会这个信号，但是也不会丢弃子进行状态，所以如果不用 wait/waitpid 对其子进行进行状态信息回收，会产生僵尸进程；
> 如果进程设置信号 SIGCLD 的处理动作为 SIG_IGN，该进程的子进程将不会变成僵尸进程。这和默认的处理动作（SIG_DFL）是不同的，子进程状态信息会被丢弃，也就是自动回收了，所以不会产生僵尸进程，但问题是，如果随后调用 wait/waitpid，也无法捕捉到子进程的状态信息，并且会阻塞到所有的子进程结束，返回错误 ECHILD，也就是没有子进程等待的情况下调用 wait/waitpid 的情况。

[SIGCLD语义](https://blog.csdn.net/caianye/article/details/6453774)
[信号](https://www.cnblogs.com/suzhou/p/4488618.html)


## 孤儿进程
即没有父进程的进程（父进程出于某些原因提前终止了），这时候该进程会重新找一个父进程。这个动作由父进程在调用 exit() 退出时，会调用 exit_notify()向其父进程发送信号，并给子进程重新找一个父进程：在当前线程组中寻找，如果失败则转由 init 进程作为父进程。
由 init 进程收养的孤儿进程不会变成僵尸进程。init 进程的机制是，无论何时只要有一个子进程终止，init 就会调用 wait 取得其终止状态，也就防止了系统中滞留（init 的子进程造成的）僵死进程。所以从这个角度看，孤儿进程并不会造成什么副作用。

[僵尸进程 孤儿进程](https://www.cnblogs.com/Anker/p/3271773.html)