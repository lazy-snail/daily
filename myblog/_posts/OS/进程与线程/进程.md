---
title: 进程
date: 2018-04-10 23:20:06
categories: OS
tags: [OS, 进程]
---
# 进程
程序本身并不是进程，进程是 **处于执行期的程序以及相关的资源的总称**，也叫任务（task）。
Linux 内核通常把进程叫做任务，线程仅仅被视为一个与其它进程共享某些资源的进程。

## 进程三种基础状态：
* **运行态**，该时刻进程实际占用CPU；
* **就绪态**，可运行，但因为其他进程正在运行而暂时停止；
* **阻塞态**，除非某外部事件发生，否则不能运行。
{% asset_img 三状态进程模型.PNG 进程状态转换 %}

此外，还有五状态进程模型、七状态进程模型：
{% asset_img 五状态进程模型.PNG 进程状态转换 %}
{% asset_img 七状态进程模型.PNG 进程状态转换 %}

## 进程控制块
Process Control Block，PCB

# 相关概念

## 临界区
《现代操作系统》中对临界区的定义：对共享内存进行访问的程序片段（代码段），就是临界区。
进一步解释，当多个进程都要使用同一个共享资源时，它的代码里会有相应的操作，这些代码段就叫做临界区/互斥区。所谓临界区：是多个进程，对某一个临界资源实施操作的程序片段，也就是说这些程序片段分散在不同的进程中，它们的共同的特点，是对同一个临界资源进行一些操作。即这一段代码，和另外一个进程的这一段代码，他们互为临界区。
临界区问题是设计一个以便进程协作的协议。其解答必须满足三个条件：
* **互斥（mutual exclusion）**：如果有一个进程在其临界区内执行，那么其他进程都不能在其临界区内执行；
* **前进（progress）**：如果没有进程在其临界区内执行，且有进程需要进入临界区，那么只有那些不在剩余区内执行的进程可参与选择，以确定下一个进入临界区的进程，且这种选择不能无限推迟；
* **有限等待（bounded waiting）**：从一个进程做出进入临界区的请求，直到该请求允许为止，其他进程允许进入其临界区的次数有上限。

临界区问题的解决都需要一个简单的工具——锁：从硬件到软件 API 实现，都需要实现锁的概念。

## 忙等待 & 自旋锁
**忙等待（busy waiting）**，进程在得到临界区访问权之前，持续循环测试而不做其他事情，浪费了 CPU 资源，所以单核处理器时应避免忙等待。克服忙等待的方式是修改信号量操作的定义，将一个进程执行 wait() 操作时，不进入忙等待，而是阻塞自己，从而将控制权转到 CPU 调度程序，以选择另一个进程来执行（需要上下文切换）。
**自旋锁（spin lock）**，允许忙等待，进程在其等待锁时还在运行，这在多处理器中常用到。优点在于：进程在等待锁时不进行上下文切换，而这种切换可能会花费相当长的时间。因此，如果锁的占用时间短，自旋锁就很有用。多处理器系统中常用自旋锁，这样一个线程在一个处理器上自旋时，另一个线程可以在另一个处理器上进入其临界区。

[参考]{https://www.cnblogs.com/youngforever/p/3250270.html)